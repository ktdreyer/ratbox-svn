diff -urN ircd-hybrid-7/include/class.h ircd-hybrid-7+lmh/include/class.h
--- ircd-hybrid-7/include/class.h	Sat Mar  9 21:48:35 2002
+++ ircd-hybrid-7+lmh/include/class.h	Sat Jun 15 12:26:15 2002
@@ -28,38 +28,47 @@
 struct ConfItem;
 struct Client;
 
-struct Class {
-  struct Class* next;     /* list node pointer */
-  char*		className;
-  int           type;
-  int           conFreq;
-  int           pingFreq;
-  int           maxLinks;
-  long          maxSendq;
-  char*         servname;
-  int           servport;
-  int           links;
+struct Class
+{
+  struct Class *next;
+  char *class_name;
+  int max_total;
+  int max_local;
+  int max_global;
+  int max_ident;
+  int max_sendq;
+  int con_freq;
+  int ping_freq;
+  int total;
 };
 
+struct Class *ClassList;
 
-#define ClassName(x)	((x)->className)
-#define ClassType(x)    ((x)->type)
-#define ConFreq(x)      ((x)->conFreq)
-#define PingFreq(x)     ((x)->pingFreq)
-#define MaxLinks(x)     ((x)->maxLinks)
-#define MaxSendq(x)     ((x)->maxSendq)
-#define Links(x)        ((x)->links)
+#define ClassName(x)	((x)->class_name)
+#define ConFreq(x)      ((x)->con_freq)
+#define MaxLocal(x)	((x)->max_local)
+#define MaxGlobal(x)	((x)->max_global)
+#define MaxIdent(x)	((x)->max_ident)
+#define MaxUsers(x)	((x)->max_total)
+#define PingFreq(x)     ((x)->ping_freq)
+#define MaxSendq(x)     ((x)->max_sendq)
+#define CurrUsers(x)    ((x)->total)
 
 #define ClassPtr(x)      ((x)->c_class)
-#define ConfLinks(x)     (ClassPtr(x)->links)
-#define ConfMaxLinks(x)  (ClassPtr(x)->maxLinks)
+
 #define ConfClassName(x) (ClassPtr(x)->class_name)
-#define ConfClassType(x) (ClassPtr(x)->type)
-#define ConfConFreq(x)   (ClassPtr(x)->conFreq)
-#define ConfPingFreq(x)  (ClassPtr(x)->pingFreq)
-#define ConfSendq(x)     (ClassPtr(x)->maxSendq)
+#define ConfConFreq(x)   (ClassPtr(x)->con_freq)
+#define ConfMaxLocal(x)  (ClassPtr(x)->max_local)
+#define ConfMaxGlobal(x) (ClassPtr(x)->max_global)
+#define ConfMaxIdent(x)  (ClassPtr(x)->max_ident)
+#define ConfMaxUsers(x)  (ClassPtr(x)->max_total)
+#define ConfPingFreq(x)  (ClassPtr(x)->ping_freq)
+#define ConfMaxSendq(x)  (ClassPtr(x)->max_sendq)
+#define ConfCurrUsers(x) (ClassPtr(x)->total)
+
+void add_class(struct Class *);
 
-extern struct Class* ClassList;  /* GLOBAL - class list */
+struct Class *make_class(void);
 
 extern  long    get_sendq(struct Client *);
 extern  int     get_con_freq(struct Class* );
@@ -69,7 +78,6 @@
 extern  void    check_class(void);
 extern  void    initclass(void);
 extern  void    free_class(struct Class* );
-extern  void    add_class (char *, int, int, int, long);
 extern  void    fix_class (struct ConfItem *, struct ConfItem *);
 extern  void    report_classes (struct Client *);
 
diff -urN ircd-hybrid-7/include/client.h ircd-hybrid-7+lmh/include/client.h
--- ircd-hybrid-7/include/client.h	Fri Jun 14 20:38:11 2002
+++ ircd-hybrid-7+lmh/include/client.h	Sat Jun 15 12:26:16 2002
@@ -127,6 +127,7 @@
   struct Client*    prev;
   struct Client*    hnext;
   struct Client*    idhnext;
+  struct Client*    hostnext;
 	
   struct Client*    lnext;      /* Used for Server->servers/users */
   struct Client*    lprev;      /* Used for Server->servers/users */
@@ -434,6 +435,7 @@
 #define FLAGS2_OPER_DIE         0x0800  /* oper can die */
 #define FLAGS2_OPER_REHASH      0x1000  /* oper can rehash */
 #define FLAGS2_OPER_ADMIN       0x2000  /* oper can set umode +a */
+#define FLAGS2_OPER_XLINE       0x4000  /* oper can xline */
 #define FLAGS2_OPER_FLAGS       (FLAGS2_OPER_GLOBAL_KILL | \
                                  FLAGS2_OPER_REMOTE | \
                                  FLAGS2_OPER_UNKLINE | \
@@ -442,6 +444,7 @@
                                  FLAGS2_OPER_K | \
                                  FLAGS2_OPER_DIE | \
                                  FLAGS2_OPER_REHASH| \
+				 FLAGS2_OPER_XLINE | \
                                  FLAGS2_OPER_ADMIN)
 
 #define FLAGS2_CBURST		0x10000  /* connection burst being sent */
@@ -559,6 +562,8 @@
 #define SetOperN(x)             ((x)->flags2 |= FLAGS2_OPER_N)
 #define IsOperK(x)              ((x)->flags2 & FLAGS2_OPER_K)
 #define SetOperK(x)             ((x)->flags2 |= FLAGS2_OPER_K)
+#define IsOperXline(x)          ((x)->flags2 & FLAGS2_OPER_XLINE)
+#define SetOperXline(x)         ((x)->flags2 |= FLAGS2_OPER_XLINE)
 #define IsOperDie(x)            ((x)->flags2 & FLAGS2_OPER_DIE)
 #define SetOperDie(x)           ((x)->flags2 |= FLAGS2_OPER_DIE)
 #define IsOperRehash(x)         ((x)->flags2 & FLAGS2_OPER_REHASH)
diff -urN ircd-hybrid-7/include/config.h ircd-hybrid-7+lmh/include/config.h
--- ircd-hybrid-7/include/config.h	Tue Jun 11 02:02:24 2002
+++ ircd-hybrid-7+lmh/include/config.h	Sat Jun 15 12:26:16 2002
@@ -102,6 +102,7 @@
 #define CPATH   ETCPATH "IRCD.CONF"             /* config file */
 #define KPATH   ETCPATH "KLINE.CONF"            /* kline file */
 #define DLPATH  ETCPATH "DLINE.CONF"            /* dline file */
+#define XPATH	ETCPATH "XLINE.CONF"		/* xline file */
 #define GPATH   LOGPATH "GLINE.LOG"             /* gline logfile */
 #define RPATH   ETCPATH "IRCD.RSA"              /* RSA private key file */
 #define MPATH   ETCPATH "IRCD.MOTD"             /* MOTD filename */
@@ -148,6 +149,7 @@
 #define CPATH   ETCPATH "/ircd.conf"            /* ircd.conf file */
 #define KPATH   ETCPATH "/kline.conf"           /* kline file */
 #define DLPATH  ETCPATH "/dline.conf"           /* dline file */
+#define XPATH	ETCPATH "/xline.conf"		/* xline file */
 #define GPATH   LOGPATH "/gline.log"            /* gline logfile */
 #define RPATH   ETCPATH "/ircd.rsa"             /* ircd rsa private keyfile */
 #define MPATH   ETCPATH "/ircd.motd"            /* MOTD file */
@@ -327,6 +329,9 @@
  * these disabled, who knows. keep this enabled during development.
  */
 #define INVARIANTS
+
+#define RELNAME "+lmh1"
+#define IRCDNAME PATCHLEVEL RELNAME
 
 #define CONFIG_H_LEVEL_7
 
diff -urN ircd-hybrid-7/include/handlers.h ircd-hybrid-7+lmh/include/handlers.h
--- ircd-hybrid-7/include/handlers.h	Sat Jan  5 09:14:28 2002
+++ ircd-hybrid-7+lmh/include/handlers.h	Sat Jun 15 12:26:16 2002
@@ -95,5 +95,9 @@
 extern void m_unregistered(struct Client*, struct Client*, int, char**);
 extern void m_unsupported(struct Client*, struct Client*, int, char**);
 
+#ifdef FL_DEBUG
+extern void mo_hash(struct Client*, struct Client*, int, char**);
+#endif
+
 #endif /* INCLUDED_handlers_h */
 
diff -urN ircd-hybrid-7/include/hash.h ircd-hybrid-7+lmh/include/hash.h
--- ircd-hybrid-7/include/hash.h	Sat May 25 00:34:07 2002
+++ ircd-hybrid-7+lmh/include/hash.h	Sat Jun 15 12:26:16 2002
@@ -39,6 +39,9 @@
  */
 #define CH_MAX 16384
 
+/* hostname hash table size */
+#define HOST_MAX 131072
+
 /*
  * RESV hash table size
  *
@@ -79,6 +82,10 @@
 extern struct Client* find_client(const char* name);
 extern struct Client* find_server(const char* name);
 extern struct Client* hash_find_server(const char* name);
+
+struct Client *find_hostname(const char *);
+void del_from_hostname_hash_table(const char *, struct Client *);
+void add_to_hostname_hash_table(const char *, struct Client *);
 
 extern void add_to_resv_hash_table(const char *name,
                                    struct ResvChannel *resv_p);
diff -urN ircd-hybrid-7/include/modules.h ircd-hybrid-7+lmh/include/modules.h
--- ircd-hybrid-7/include/modules.h	Sat May 25 02:38:09 2002
+++ ircd-hybrid-7+lmh/include/modules.h	Sat Jun 15 12:26:16 2002
@@ -97,6 +97,9 @@
 extern struct Message eob_msgtab;
 extern struct Message error_msgtab;
 extern struct Message gline_msgtab;
+#ifdef FL_DEBUG
+extern struct Message hash_msgtab;
+#endif
 extern struct Message help_msgtab;
 extern struct Message info_msgtab;
 extern struct Message invite_msgtab;
diff -urN ircd-hybrid-7/include/s_conf.h ircd-hybrid-7+lmh/include/s_conf.h
--- ircd-hybrid-7/include/s_conf.h	Sat May 25 00:34:08 2002
+++ ircd-hybrid-7+lmh/include/s_conf.h	Sat Jun 15 12:26:16 2002
@@ -162,6 +162,7 @@
 #define CONF_OPER_REHASH        0x0040
 #define CONF_OPER_DIE           0x0080
 #define CONF_OPER_ADMIN         0x0100
+#define CONF_OPER_XLINE		0x0200
 
 struct config_file_entry
 {
@@ -169,6 +170,7 @@
   char *configfile;
   char *klinefile;
   char *dlinefile;
+  char *xlinefile;
 
   char *glinefile;
 
@@ -231,6 +233,7 @@
   int           throttle_time;
   int           use_egd;
   int		ping_cookie;
+  int		use_global_limits;
 #ifdef HAVE_LIBCRYPTO
   struct EncCapability *default_cipher_preference;
 #endif
@@ -317,8 +320,15 @@
 extern struct admin_info  AdminInfo;        /* defined in ircd.c */
 /* End GLOBAL section */
 
-dlink_list temporary_klines;
-dlink_list temporary_ip_klines;
+#define TEMP_MIN	1
+#define TEMP_HOUR	2
+#define TEMP_DAY	3
+#define TEMP_WEEK	4
+
+dlink_list temporary_min;
+dlink_list temporary_hour;
+dlink_list temporary_day;
+dlink_list temporary_week;
 
 extern void clear_ip_hash_table(void);
 extern void iphash_stats(struct Client *,struct Client *,int,char **,FBFILE*);
@@ -352,7 +362,7 @@
 extern char *oper_flags_as_string(int);
 extern char *oper_privs_as_string(struct Client *, int);
 
-extern int find_u_conf(char*, char*, char *);
+extern int find_u_conf(char*, char*, char *, int);
 extern struct ConfItem *find_x_conf(char*);
 
 extern struct ConfItem* find_tkline(const char*, const char*, struct irc_inaddr *);
@@ -378,9 +388,15 @@
 			       const char *oper_reason,
 			       const char *current_date, time_t cur_time );
 extern  void    add_temp_kline(struct ConfItem *);
+extern void	add_temp_dline(struct ConfItem *);
 extern  void    report_temp_klines(struct Client *);
 extern  void    show_temp_klines(struct Client *, dlink_list *);
-extern  void    cleanup_tklines(void *notused);
+
+extern void cleanup_temps_min(void *);
+extern void cleanup_temps_hour(void *);
+extern void cleanup_temps_day(void *);
+extern void cleanup_temps_week(void *);
+
 
 extern  const   char *get_conf_name(KlineType);
 extern  int     rehash (int);
@@ -401,6 +417,7 @@
 /* XXX consider moving these into kdparse.h */
 extern void parse_k_file(FBFILE *fb);
 extern void parse_d_file(FBFILE *fb);
+extern void parse_x_file(FBFILE *fb);
 extern char *getfield(char *newline);
 
 extern char *get_oper_name(struct Client *client_p);
@@ -412,11 +429,11 @@
 #define NOT_AUTHORIZED  (-1)
 #define SOCKET_ERROR    (-2)
 #define I_LINE_FULL     (-3)
-#define TOO_MANY        (-4)
-#define BANNED_CLIENT   (-5)
-#define TOO_FAST        (-6)
-
-#define CLEANUP_TKLINES_TIME 60
+#define BANNED_CLIENT   (-4)
+#define TOO_FAST        (-5)
+#define TOO_MANY_LOCAL	(-6)
+#define TOO_MANY_GLOBAL (-7)
+#define TOO_MANY_IDENT	(-8)
 
 #endif /* INCLUDED_s_conf_h */
 
diff -urN ircd-hybrid-7/include/s_serv.h ircd-hybrid-7+lmh/include/s_serv.h
--- ircd-hybrid-7/include/s_serv.h	Sat May 25 00:34:08 2002
+++ ircd-hybrid-7+lmh/include/s_serv.h	Sat Jun 15 12:26:16 2002
@@ -74,12 +74,13 @@
 
 #define CAP_TBURST	0x00040000   /* supports TBURST */
 #define CAP_PARA	0x00080000   /* supports invite broadcasting for +p */
+#define CAP_UNKLN       0x00100000   /* supports remote unkline */
 
 #define CAP_MASK        (CAP_QS  | CAP_EX   | CAP_CHW  | \
                          CAP_IE  | CAP_EOB  | CAP_KLN  | \
                          CAP_GLN | CAP_HOPS | CAP_AOPS | \
                          CAP_UID | CAP_ZIP  | CAP_ENC | \
-                         CAP_KNOCK  | CAP_PARA)
+                         CAP_KNOCK  | CAP_PARA | CAP_UNKLN)
 
 #ifdef HAVE_LIBZ
 #define CAP_ZIP_SUPPORTED       CAP_ZIP
diff -urN ircd-hybrid-7/modules/Makefile.in ircd-hybrid-7+lmh/modules/Makefile.in
--- ircd-hybrid-7/modules/Makefile.in	Mon Jun  3 13:15:06 2002
+++ ircd-hybrid-7+lmh/modules/Makefile.in	Sat Jun 15 12:26:16 2002
@@ -103,7 +103,8 @@
   m_wallops.c \
   m_who.c \
   m_whois.c \
-  m_whowas.c 
+  m_whowas.c \
+  m_xline.c
 
 ALL_SRCS = $(CORE_SRCS) \
            $(SRCS)
diff -urN ircd-hybrid-7/modules/m_kline.c ircd-hybrid-7+lmh/modules/m_kline.c
--- ircd-hybrid-7/modules/m_kline.c	Sat May 25 00:34:20 2002
+++ ircd-hybrid-7+lmh/modules/m_kline.c	Sat Jun 15 12:26:16 2002
@@ -90,12 +90,17 @@
 static int valid_user_host(struct Client *source_p, char *user, char *host);
 static int valid_wild_card(char *user, char *host);
 static int already_placed_kline(struct Client*, char*, char*);
+
 static void apply_kline(struct Client *source_p, struct ConfItem *aconf,
                         const char *reason, const char *oper_reason,
 			const char *current_date, time_t cur_time);
-
+static void apply_dline(struct Client *source_p, struct ConfItem *aconf,
+		        const char *reason, const char *oper_reason,
+			const char *current_date, time_t cur_time);
 static void apply_tkline(struct Client *source_p, struct ConfItem *aconf,
                          const char *current_date, int temporary_kline_time);
+static void apply_tdline(struct Client *source_p, struct ConfItem *aconf,
+		         const char *current_date, int temporary_kline_time);
 
 
 char buffer[IRCD_BUFSIZE];
@@ -317,7 +322,8 @@
 
   tkline_time = atoi(parv[2]);
 
-  if(find_u_conf((char *)source_p->user->server, source_p->username, source_p->host))
+  if(find_u_conf((char *)source_p->user->server, source_p->username, source_p->host,
+	         CONF_OPER_K))
     {
       sendto_realops_flags(FLAGS_ALL, L_ALL,
 			   "*** Received K-Line for [%s@%s] [%s], from %s!%s@%s on %s",
@@ -397,6 +403,43 @@
  check_klines();
 }
 
+/* apply_dline
+ *
+ * input	- dline info
+ * output	- none
+ * side effects - dline is added to hashtable
+ */
+static void apply_dline(struct Client *source_p, struct ConfItem *aconf,
+		        const char *reason, const char *oper_reason,
+			const char *current_date, time_t cur_time)
+{
+  add_conf_by_address(aconf->host, CONF_DLINE, NULL, aconf);
+  WriteKlineOrDline(DLINE_TYPE, source_p, NULL, aconf->host, reason,
+		    oper_reason, current_date, cur_time);
+}
+
+/* apply_tdline
+ *
+ * input	- dline info
+ * output	- none
+ * side effects - tdline is added
+ */
+static void apply_tdline(struct Client *source_p, struct ConfItem *aconf,
+		         const char *current_date, int tdline_time)
+{
+  aconf->hold = CurrentTime + tdline_time;
+  add_temp_dline(aconf);
+  sendto_realops_flags(FLAGS_ALL, L_ALL,
+		       "%s added temporary %d min. D-Line for [%s] [%s]",
+		       source_p->name, tdline_time/60, 
+		       aconf->host, aconf->passwd);
+
+  sendto_one(source_p, ":%s NOTICE %s :Added temporary %d min. D-Line for [%s]",
+             me.name, source_p->name, tdline_time/60, aconf->host);
+  ilog(L_TRACE, "%s added temporary %d min. D-Line for [%s] [%s]",
+       source_p->name, tdline_time/60, aconf->host, aconf->passwd);
+}
+
 /*
  * valid_tkline()
  * 
@@ -430,8 +473,8 @@
   if(result == 0)
     result = 1;
 
-  if(result > (24*60))
-    result = (24*60); /* Max it at 24 hours */
+  if(result > (24*60*7*4))
+    result = (24*60*7*4); /* Max it at 4 weeks */
 
   result = (time_t)result * (time_t)60;  /* turn it into seconds */
 
@@ -574,6 +617,8 @@
   char dlbuffer[1024];
   const char* current_date;
   time_t cur_time;
+  time_t tdline_time = 0;
+  int loc = 0;
 
   if(!IsOperK(source_p))
     {
@@ -581,7 +626,23 @@
       return;
     }
 
-  dlhost = parv[1];
+  loc++;
+
+  tdline_time = valid_tkline(source_p, parv[loc]);
+
+  if(tdline_time == -1)
+    return;
+  else if(tdline_time) 
+    loc++;
+
+  if(parc < loc+1)
+  {
+    sendto_one(source_p, form_str(ERR_NEEDMOREPARAMS),
+	       me.name, source_p->name, "DLINE");
+    return;
+  }
+  
+  dlhost = parv[loc];
   strlcpy(cidr_form_host, dlhost, HOSTLEN);
   cidr_form_host[HOSTLEN] = '\0';
 
@@ -592,7 +653,7 @@
               me.name, parv[0]);
    return;
 #else
-      if (!(target_p = find_chasing(source_p, parv[1], NULL)))
+      if (!(target_p = find_chasing(source_p, parv[loc], NULL)))
         return;
 
       if(!target_p->user)
@@ -658,14 +719,15 @@
 #endif
     }
 
+  loc++;
 
-  if (parc > 2) /* host :reason */
+  if (parc >= loc+1) /* host :reason */
     {
-      if ( valid_comment(source_p,parv[2]) == 0 )
+      if ( valid_comment(source_p, parv[loc]) == 0 )
 	return;
 
-      if(*parv[2])
-        reason = parv[2];
+      if(*parv[loc])
+        reason = parv[loc];
       else
         reason = "No reason";
     }
@@ -726,18 +788,23 @@
       oper_reason++;
     }
 
-  ircsprintf(dlbuffer, "%s (%s)",reason, current_date);
-
   aconf->status = CONF_DLINE;
   DupString(aconf->host, dlhost);
-  DupString(aconf->passwd, dlbuffer);
+  
+  if(tdline_time)
+  {
+    ircsprintf(dlbuffer, "Temporary D-line %d min. - %s (%s)",
+	       (int)(tdline_time/60), reason, current_date);
+    DupString(aconf->passwd, dlbuffer);
+    apply_tdline(source_p, aconf, current_date, tdline_time);
+  }
+  else
+  {
+    ircsprintf(dlbuffer, "%s (%s)",reason, current_date);
+    DupString(aconf->passwd, dlbuffer);
+    apply_dline(source_p, aconf, reason, oper_reason, current_date, cur_time);
+  }
 
-  add_conf_by_address(aconf->host, CONF_DLINE, NULL, aconf);
-  /*
-   * Write dline to configuration file
-   */
-  WriteKlineOrDline(DLINE_TYPE, source_p, NULL, dlhost, reason,
-		    oper_reason, current_date, cur_time);
   check_klines();
 } /* m_dline() */
 
diff -urN ircd-hybrid-7/modules/m_trace.c ircd-hybrid-7+lmh/modules/m_trace.c
--- ircd-hybrid-7/modules/m_trace.c	Sat May 25 00:34:23 2002
+++ ircd-hybrid-7+lmh/modules/m_trace.c	Sat Jun 15 12:26:16 2002
@@ -277,9 +277,9 @@
     }
     
   for (cltmp = ClassList; doall && cltmp; cltmp = cltmp->next)
-    if (Links(cltmp) > 0)
+    if (CurrUsers(cltmp) > 0)
       sendto_one(source_p, form_str(RPL_TRACECLASS), me.name,
-                 parv[0], ClassName(cltmp), Links(cltmp));
+                 parv[0], ClassName(cltmp), CurrUsers(cltmp));
 		 
   sendto_one(source_p, form_str(RPL_ENDOFTRACE),me.name, parv[0],tname);
 }
diff -urN ircd-hybrid-7/modules/m_unkline.c ircd-hybrid-7+lmh/modules/m_unkline.c
--- ircd-hybrid-7/modules/m_unkline.c	Sat May 25 00:34:23 2002
+++ ircd-hybrid-7+lmh/modules/m_unkline.c	Sat Jun 15 12:26:16 2002
@@ -42,15 +42,17 @@
 #include "s_gline.h"
 #include "parse.h"
 #include "modules.h"
+#include "s_serv.h"
 
 
 static void mo_unkline(struct Client*, struct Client*, int, char**);
+static void ms_unkline(struct Client*, struct Client*, int, char**);
 static void mo_undline(struct Client*, struct Client*, int, char**);
 static void mo_ungline(struct Client*, struct Client*, int, char**);
 
 struct Message msgtabs[] = {
   {"UNKLINE", 0, 0, 2, 0, MFLG_SLOW, 0,
-   {m_unregistered, m_not_oper, m_error, mo_unkline}},
+   {m_unregistered, m_not_oper, ms_unkline, mo_unkline}},
   {"UNDLINE", 0, 0, 2, 0, MFLG_SLOW, 0,
    {m_unregistered, m_not_oper, m_error, mo_undline}}, 
   {"UNGLINE", 0, 0, 2, 0, MFLG_SLOW, 0,
@@ -76,8 +78,10 @@
 const char *_version = "$Revision$";
 #endif
 
+static void remove_permkline_match(struct Client *, char *, char *);
 static int flush_write(struct Client *, FBFILE* , char *, char *);
-static int remove_tkline_match(char *,char *);
+static int remove_temp_match(char *,char *);
+static int remove_temp_match_list(char *, char *, dlink_list *);
 
 
 /*
@@ -93,19 +97,14 @@
 static void mo_unkline (struct Client *client_p,struct Client *source_p,
                        int parc,char *parv[])
 {
-  FBFILE *in, *out;
-  int pairme=0,error_on_write = NO;
-  char buf[BUFSIZE], buff[BUFSIZE], temppath[BUFSIZE], *user, *host, *p;
-  const char  *filename;                /* filename to use for unkline */
-  mode_t oldumask;
+  char *user, *host;
 
-  ircsprintf(temppath, "%s.tmp", ConfigFileEntry.klinefile);
-  
   if (!IsOperUnkline(source_p))
     {
       sendto_one(source_p,":%s NOTICE %s :You need unkline = yes;",me.name,parv[0]);
       return;
     }
+
   if (parc < 2)
     {
       sendto_one(source_p, form_str(ERR_NEEDMOREPARAMS),
@@ -135,7 +134,21 @@
       return;
     }
 
-  if (remove_tkline_match(host, user))
+  /* possible remote kline.. */
+  if(parc > 3)
+  {
+    if(irccmp(parv[2], "ON") == 0)
+    {
+      sendto_server(NULL, source_p, NULL, CAP_UNKLN, NOCAPS, LL_ICLIENT,
+		    ":%s UNKLINE %s %s %s",
+		    source_p->name, parv[3], user, host);
+      
+      if(match(parv[3], me.name) == 0)
+        return;
+    }
+  }
+
+  if(remove_temp_match(host, user))
     {
       sendto_one(source_p,
 		 ":%s NOTICE %s :Un-klined [%s@%s] from temporary k-lines",
@@ -148,10 +161,92 @@
       return;
     }
 
+  remove_permkline_match(source_p, host, user);
+}
+
+/* ms_unkline()
+ *
+ * input	- pointer to servere
+ * 		- pointer to client
+ * 		- parm count
+ * 		- params
+ * output	- none
+ * side effects - kline is removed if matching shared {} is found.
+ */
+static void ms_unkline(struct Client *client_p, struct Client *source_p,
+		     int parc, char *parv[])
+{
+  char *kuser;
+  char *khost;
+  
+  if(parc != 4)
+    return;
+
+  /* parv[0]  parv[1]        parv[2]  parv[3]
+   * oper     target server  user     host    */
+  sendto_server(client_p, source_p, NULL, CAP_UNKLN, NOCAPS, LL_ICLIENT,
+		":%s UNKLINE %s %s %s",
+		parv[0], parv[1], parv[2], parv[3]);
+
+  kuser = parv[2];
+  khost = parv[3];
+
+  if(!match(parv[1], me.name))
+    return;
+
+  if(!IsPerson(source_p))
+    return;
+
+  if(find_u_conf((char *)source_p->user->server, source_p->username,
+                 source_p->host, CONF_OPER_UNKLINE))
+  {
+    sendto_realops_flags(FLAGS_ALL, L_ALL,
+	       "*** Received Un-kline for [%s@%s], from %s",
+	       kuser, khost, get_oper_name(source_p));
+
+    if(remove_temp_match(khost, kuser))
+    {
+      sendto_one(source_p,
+	         ":%s NOTICE %s :Un-klined [%s@%s] from temporary k-lines",
+		 me.name, parv[0],kuser, khost);
+
+      sendto_realops_flags(FLAGS_ALL, L_ALL,
+	                   "%s has removed the temporary K-Line for: [%s@%s]",
+			   get_oper_name(source_p), kuser, khost);
+
+      ilog(L_NOTICE, "%s removed temporary K-Line for [%s@%s]",
+	   source_p->name, kuser, khost);
+      return;
+    }
+
+    remove_permkline_match(source_p, khost, kuser);    
+  }
+}
+
+/* remove_permkline_match()
+ *
+ * hunts for a permanent kline, and removes it.
+ */
+static void remove_permkline_match(struct Client *source_p,
+	                           char *host, char *user)
+{
+  FBFILE *in, *out;
+  int pairme = 0;
+  int error_on_write = NO;
+  char buf[BUFSIZE];
+  char buff[BUFSIZE];
+  char temppath[BUFSIZE];
+  const char *filename;
+  mode_t oldumask;
+  char *p;
+  
+  ircsprintf(temppath, "%s.tmp", ConfigFileEntry.klinefile);
+  
   filename = get_conf_name(KLINE_TYPE);
+
   if ((in = fbopen(filename, "r")) == 0)
     {
-      sendto_one(source_p, ":%s NOTICE %s :Cannot open %s", me.name, parv[0],
+      sendto_one(source_p, ":%s NOTICE %s :Cannot open %s", me.name, source_p->name,
 		 filename);
       return;
     }
@@ -159,8 +254,8 @@
   oldumask = umask(0);
   if ((out = fbopen(temppath, "w")) == 0)
     {
-      sendto_one(source_p, ":%s NOTICE %s :Cannot open %s", me.name, parv[0],
-		 temppath);
+      sendto_one(source_p, ":%s NOTICE %s :Cannot open %s",
+	         me.name, source_p->name, temppath);
       fbclose(in);
       umask(oldumask);
       return;
@@ -231,6 +326,11 @@
     {
       sendto_one(source_p, ":%s NOTICE %s :No K-Line for %s@%s",
                  me.name, source_p->name,user,host);
+
+      if(!MyClient(source_p))
+        sendto_realops_flags(FLAGS_ALL, L_ALL, 
+			"*** Remote Un-Kline for [%s@%s] is not K-Lined.",
+			user, host);
       return;
     }
 
@@ -245,6 +345,8 @@
   return; 
 }
 
+    
+  
 /*
  * flush_write()
  *
@@ -287,30 +389,45 @@
  * Side effects: Any matching tklines are removed.
  */
 static int
-remove_tkline_match(char *host, char *user)
+remove_temp_match(char *host, char *user)
 {
-  struct ConfItem *tk_c;
-  dlink_node *tk_n;
+  if(remove_temp_match_list(host, user, &temporary_hour) ||
+     remove_temp_match_list(host, user, &temporary_day) ||
+     remove_temp_match_list(host, user, &temporary_min) ||
+     remove_temp_match_list(host, user, &temporary_week))
+    return YES;
+
+  return NO;
+}
+
+static int
+remove_temp_match_list(char *host, char *user, dlink_list *temp_list)
+{
+  struct ConfItem *aconf;
+  dlink_node *ptr;
   struct irc_inaddr addr, caddr;
   int nm_t, cnm_t, bits, cbits;
   nm_t = parse_netmask(host, &addr, &bits);
 
-  for (tk_n=temporary_klines.head; tk_n; tk_n=tk_n->next)
+  for(ptr = temp_list->head; ptr; ptr = ptr->next)
     {
-      tk_c = (struct ConfItem*)tk_n->data;
-      cnm_t = parse_netmask(tk_c->host, &caddr, &cbits);
-      if (cnm_t != nm_t || irccmp(user, tk_c->user))
+      aconf = (struct ConfItem*)ptr->data;
+
+      cnm_t = parse_netmask(aconf->host, &caddr, &cbits);
+
+      if (cnm_t != nm_t || (user && irccmp(user, aconf->user)))
 	continue;
-      if ((nm_t==HM_HOST && !irccmp(tk_c->host, host)) ||
+
+      if ((nm_t==HM_HOST && !irccmp(aconf->host, host)) ||
 	  (nm_t==HM_IPV4 && bits==cbits && match_ipv4(&addr, &caddr, bits))
 #ifdef IPV6
 	  || (nm_t==HM_IPV6 && bits==cbits && match_ipv6(&addr, &caddr, bits))
 #endif
 	  )
 	{
-	  dlinkDelete(tk_n, &temporary_klines);
-	  free_dlink_node(tk_n);
-	  delete_one_address_conf(tk_c->host, tk_c);
+	  dlinkDelete(ptr, temp_list);
+	  free_dlink_node(ptr);
+	  delete_one_address_conf(aconf->host, aconf);
 	  return YES;
 	}
     }
@@ -333,7 +450,8 @@
   FBFILE* in;
   FBFILE* out;
   char  buf[BUFSIZE], buff[BUFSIZE], temppath[BUFSIZE], *p;
-  const char  *filename,*cidr, *found_cidr;
+  const char  *filename, *found_cidr;
+  char *cidr;
   int pairme = NO, error_on_write = NO;
   mode_t oldumask;
 
@@ -356,6 +474,18 @@
       return;
     }
 #endif
+
+  if(remove_temp_match(cidr, NULL))
+  {
+    sendto_one(source_p,
+	       ":%s NOTICE %s :Un-dlined [%s] from temporary D-lines",
+	       me.name, parv[0], cidr);
+    sendto_realops_flags(FLAGS_ALL, L_ALL,
+                         "%s has removed the temporary D-Line for: [%s]",
+			 get_oper_name(source_p), cidr);
+    ilog(L_NOTICE, "%s removed temporary D-Line for [%s]", parv[0], cidr);
+    return;
+  }
 
   filename = get_conf_name(DLINE_TYPE);
 
diff -urN ircd-hybrid-7/modules/m_xline.c ircd-hybrid-7+lmh/modules/m_xline.c
--- ircd-hybrid-7/modules/m_xline.c	Thu Jan  1 01:00:00 1970
+++ ircd-hybrid-7+lmh/modules/m_xline.c	Sat Jun 15 12:26:16 2002
@@ -0,0 +1,146 @@
+/* modules/m_xline.c
+ * Copyright (C) 2002 Hybrid Development Team
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ * 1.Redistributions of source code must retain the above copyright notice,
+ *   this list of conditions and the following disclaimer.
+ * 2.Redistributions in binary form must reproduce the above copyright
+ *   notice, this list of conditions and the following disclaimer in the
+ *   documentation and/or other materials provided with the distribution.
+ * 3.The name of the author may not be used to endorse or promote products
+ *   derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $Id$
+ */
+
+#include "stdinc.h"
+#include "tools.h"
+#include "handlers.h"
+#include "send.h"
+#include "channel.h"
+#include "client.h"
+#include "common.h"
+#include "config.h"
+#include "class.h"
+#include "ircd.h"
+#include "numeric.h"
+#include "memory.h"
+#include "s_log.h"
+#include "s_serv.h"
+#include "whowas.h"
+#include "irc_string.h"
+#include "hash.h"
+#include "msg.h"
+#include "parse.h"
+#include "modules.h"
+#include "s_conf.h"
+
+static void mo_xline(struct Client *client_p, struct Client *source_p,
+                    int parc, char *parv[]);
+
+struct Message xline_msgtab = {
+  "XLINE", 0, 0, 3, 0, MFLG_SLOW, 0,
+  {m_unregistered, m_not_oper, m_ignore, mo_xline}
+};
+
+void
+_modinit(void)
+{
+  mod_add_cmd(&xline_msgtab);
+}
+
+void
+_moddeinit(void)
+{
+  mod_del_cmd(&xline_msgtab);
+}
+
+char *_version = "$Revision$";
+
+/* m_xline()
+ *
+ * parv[1] - thing to xline
+ * parv[2] - optional type/reason
+ * parv[3] - reason
+ */
+void 
+mo_xline(struct Client *client_p, struct Client *source_p,
+         int parc, char *parv[])
+{
+  char buffer[BUFSIZE*2];
+  FBFILE *out;
+  struct ConfItem *aconf;
+  char *reason;
+  int xtype = 1;
+
+  if(!IsOperXline(source_p))
+  {
+    sendto_one(source_p, ":%s NOTICE %s :You need xline = yes;",
+               me.name, source_p->name);
+    return;
+  }
+
+  if(parc > 3)
+  {
+    xtype = atoi(parv[2]);
+    reason = parv[3];
+  }
+  else
+  {
+    if(IsDigit(*parv[2]))
+    {
+      xtype = atoi(parv[2]);
+      reason = "No Reason";
+    }
+    else
+      reason = parv[2];
+  }
+
+  sendto_realops_flags(FLAGS_ALL, L_ALL,
+		       "%s added X-line for [%s] [%s]",
+		       get_oper_name(source_p), parv[1], reason);
+  sendto_one(source_p, ":%s NOTICE %s :Added X-line for [%s] [%s]",
+             me.name, source_p->name, parv[1], reason);
+  ilog(L_TRACE, "%s added X-line for [%s] [%s]",
+       source_p->name, parv[1], reason);
+  
+  aconf = make_conf();
+  aconf->status = CONF_XLINE;
+  DupString(aconf->host, parv[1]);
+  DupString(aconf->passwd, reason);
+  aconf->port = xtype;
+
+  collapse(aconf->host);
+  conf_add_x_conf(aconf);
+
+  if((out = fbopen(ConfigFileEntry.xlinefile, "a")) == NULL)
+  {
+    sendto_realops_flags(FLAGS_ALL, L_ALL,
+		         "*** Problem opening %s", ConfigFileEntry.xlinefile);
+    return;
+  }
+
+  ircsprintf(buffer, "\"%s\",\"%d\",\"%s\",\"%s\",%lu\n",
+             parv[1], xtype, reason, get_oper_name(source_p), CurrentTime);
+
+  if(fbputs(buffer, out) == -1)
+    sendto_realops_flags(FLAGS_ALL, L_ALL,
+		         "*** Problem writing to %s", ConfigFileEntry.xlinefile);
+
+  fbclose(out);
+}
diff -urN ircd-hybrid-7/src/class.c ircd-hybrid-7+lmh/src/class.c
--- ircd-hybrid-7/src/class.c	Sat May 25 00:34:45 2002
+++ ircd-hybrid-7+lmh/src/class.c	Sat Jun 15 12:26:17 2002
@@ -45,19 +45,19 @@
 
 struct Class* ClassList;
 
-static struct Class *make_class()
+struct Class *
+make_class(void)
 {
   struct Class        *tmp;
 
   tmp = (struct Class *)MyMalloc(sizeof(struct Class));
-  tmp->className = NULL;
-  tmp->servname = NULL;
+  memset(tmp, 0, sizeof(struct Class));
   return tmp;
 }
 
 void free_class(struct Class *tmp)
 {
-  MyFree(tmp->className);
+  MyFree(tmp->class_name);
   MyFree((char *)tmp);
 }
 
@@ -161,57 +161,40 @@
   return (DEFAULT_CONNECTFREQUENCY);
 }
 
-/*
- * add_class
+/* add_class()
  *
- * inputs	- classname to use
- * 		- ping frequency
- *		- connection frequency
- * 		- maximum links
- *		- max sendq
- * output	- NONE
- * side effects -
- * When adding a class, check to see if it is already present first.
- * if so, then update the information for that class, rather than create
- * a new entry for it and later delete the old entry.
- * if no present entry is found, then create a new one and add it in
- * immediately after the first one (class 0).
+ * input	- class to add
+ * output	-
+ * side effects - class is added to ClassList if new, else old class
+ *                is updated with new values.
  */
-void    add_class(char *classname,
-                  int ping,
-                  int confreq,
-                  int maxli,
-                  long sendq)
+void
+add_class(struct Class *classptr)
 {
-  struct Class *t, *p;
+  struct Class *tmpptr;
 
-  if(!classname)
-    return;
+  tmpptr = find_class(classptr->class_name);
 
-  t = find_class(classname);
-  if (t == ClassList)
-    {
-      p = make_class();
-      p->next = t->next;
-      t->next = p;
-    }
+  if(tmpptr == ClassList)
+  {
+    classptr->next = tmpptr->next;
+    tmpptr->next = classptr;
+    CurrUsers(classptr) = 0;
+  }
   else
-    p = t;
-  Debug((DEBUG_DEBUG,
-         "Add Class %s: p %x t %x - cf: %d pf: %d ml: %d sq: %l",
-         classname, p, t, confreq, ping, maxli, sendq));
-
-  /* classname already known to be non NULL */
-  MyFree(ClassName(p));
-  DupString(ClassName(p),classname);
-  ConFreq(p) = confreq;
-  PingFreq(p) = ping;
-  MaxLinks(p) = maxli;
-  MaxSendq(p) = (sendq > 0) ? sendq : DEFAULT_SENDQ;
-  if (p != t)
-    Links(p) = 0;
+  {
+    MaxUsers(tmpptr) = MaxUsers(classptr);
+    MaxLocal(tmpptr) = MaxLocal(classptr);
+    MaxGlobal(tmpptr) = MaxGlobal(classptr);
+    MaxIdent(tmpptr) = MaxIdent(classptr);
+    PingFreq(tmpptr) = PingFreq(classptr);
+    MaxSendq(tmpptr) = MaxSendq(classptr);
+    
+    free_class(classptr);
+  }
 }
 
+
 /*
  * find_class
  *
@@ -249,14 +232,10 @@
 
   for (cltmp2 = cltmp = ClassList; cltmp; cltmp = cltmp2->next)
     {
-      Debug((DEBUG_DEBUG,
-             "ClassName %s Class %d : CF: %d PF: %d ML: %d LI: %d SQ: %ld",
-             ClassName(cltmp),ClassType(cltmp), ConFreq(cltmp), PingFreq(cltmp),
-             MaxLinks(cltmp), Links(cltmp), MaxSendq(cltmp)));
-      if (MaxLinks(cltmp) < 0)
+      if (MaxUsers(cltmp) < 0)
         {
           cltmp2->next = cltmp->next;
-          if (Links(cltmp) <= 0)
+          if (CurrUsers(cltmp) <= 0)
             free_class(cltmp);
         }
       else
@@ -275,14 +254,11 @@
 {
   ClassList = make_class();
 
-  ClassType(ClassList) = 0;
   DupString(ClassName(ClassList),"default");
   ConFreq(ClassList) = DEFAULT_CONNECTFREQUENCY;
   PingFreq(ClassList) = DEFAULT_PINGFREQUENCY;
-  MaxLinks(ClassList) = ConfigFileEntry.maximum_links;
+  MaxUsers(ClassList) = 1;
   MaxSendq(ClassList) = DEFAULT_SENDQ;
-  Links(ClassList) = 0;
-  ClassList->next = NULL;
 }
 
 /*
@@ -299,7 +275,8 @@
   for (cltmp = ClassList; cltmp; cltmp = cltmp->next)
     sendto_one(source_p, form_str(RPL_STATSYLINE), me.name, source_p->name,
                'Y', ClassName(cltmp), PingFreq(cltmp), ConFreq(cltmp),
-               MaxLinks(cltmp), MaxSendq(cltmp));
+               MaxUsers(cltmp), MaxSendq(cltmp),
+	       MaxLocal(cltmp), MaxIdent(cltmp), MaxGlobal(cltmp), MaxIdent(cltmp));
 }
 
 /*
@@ -311,7 +288,7 @@
  */
 long    get_sendq(struct Client *client_p)
 {
-  int   sendq = DEFAULT_SENDQ, retc = BAD_CLIENT_CLASS;
+  int   sendq = DEFAULT_SENDQ;
   dlink_node      *ptr;
   struct Class    *cl;
   struct ConfItem *aconf;
@@ -326,7 +303,7 @@
         if ( !(cl = aconf->c_class))
           continue;
 
-        if (ClassType(cl) > retc)
+	if(ClassName(cl))
           sendq = MaxSendq(cl);
       }
   return sendq;
diff -urN ircd-hybrid-7/src/client.c ircd-hybrid-7+lmh/src/client.c
--- ircd-hybrid-7/src/client.c	Sun Jun  9 01:22:28 2002
+++ ircd-hybrid-7+lmh/src/client.c	Sat Jun 15 12:26:17 2002
@@ -1057,6 +1057,9 @@
 
 	if (HasID(source_p))
 	  del_from_id_hash_table(source_p->user->id, source_p);
+
+	if(ConfigFileEntry.use_global_limits)
+	  del_from_hostname_hash_table(source_p->host, source_p);
   
         /* again, this is all that is needed */
     }
diff -urN ircd-hybrid-7/src/hash.c ircd-hybrid-7+lmh/src/hash.c
--- ircd-hybrid-7/src/hash.c	Fri Jun  7 22:59:17 2002
+++ ircd-hybrid-7+lmh/src/hash.c	Sat Jun 15 12:26:17 2002
@@ -39,6 +39,8 @@
 #include "fdlist.h"
 #include "fileio.h"
 #include "memory.h"
+#include "msg.h"
+#include "handlers.h"
 
 /* New hash code */
 /*
@@ -47,11 +49,19 @@
 
 static unsigned int hash_channel_name(const char* name);
 
+#ifdef FL_DEBUG
+struct Message hash_msgtab = {
+  "HASH", 0, 0, 1, 0, MFLG_SLOW, 0,
+  {m_ignore, m_ignore, m_ignore, mo_hash}
+};
+#endif
+
 #ifdef DEBUGMODE
 static struct HashEntry* clientTable = NULL;
 static struct HashEntry* channelTable = NULL;
 static struct HashEntry* idTable = NULL;
 static struct HashEntry* resvTable = NULL;
+static struct HashEntry *hostTable = NULL;
 static int clhits;
 static int clmiss;
 static int chhits;
@@ -64,6 +74,7 @@
 static struct HashEntry channelTable[CH_MAX];
 static struct HashEntry idTable[U_MAX];
 static struct HashEntry resvTable[R_MAX];
+static struct HashEntry hostTable[HOST_MAX];
 
 #endif
 
@@ -93,7 +104,6 @@
 }
 
 /*
- *
  * look in whowas.c for the missing ...[WW_MAX]; entry
  */
 
@@ -175,6 +185,17 @@
   return (h & (CH_MAX - 1));
 }
 
+static unsigned int
+hash_hostname(const char *name)
+{
+  int i = 30;
+  unsigned int h = 0;
+
+  while(*name && --i)
+    h = (h << 4) - (h + (unsigned char)ToLower(*name++));
+
+  return (h & (HOST_MAX - 1));
+}
 
 /*
  * hash_resv_channel()
@@ -232,7 +253,7 @@
 }
 
 static void
-clear_channel_hash_table()
+clear_channel_hash_table(void)
 {
 #ifdef DEBUGMODE
   chmiss = 0;
@@ -245,6 +266,16 @@
 }
 
 static void
+clear_hostname_hash_table(void)
+{
+#ifdef DEBUGMODE
+  if(!hostTable)
+    hostTable = (struct HashEntry *)MyMalloc(HOST_MAX * sizeof(struct HashEntry));
+#endif
+  memset(hostTable, 0, sizeof(struct HashEntry) * HOST_MAX);
+}
+
+static void
 clear_resv_hash_table()
 {
 #ifdef DEBUGMODE
@@ -263,6 +294,7 @@
   clear_client_hash_table();
   clear_channel_hash_table();
   clear_id_hash_table();
+  clear_hostname_hash_table();
   clear_resv_hash_table();
 }
 
@@ -301,6 +333,24 @@
   ++clientTable[hashv].hits;
 }
 
+void
+add_to_hostname_hash_table(const char *hostname, struct Client *client_p)
+{
+  unsigned int hashv;
+
+  assert(hostname != NULL);
+  assert(client_p != NULL);
+
+  if(hostname == NULL || client_p == NULL)
+    return;
+
+  hashv = hash_hostname(hostname);
+  client_p->hostnext = (struct Client *)hostTable[hashv].list;
+  hostTable[hashv].list = (void *)client_p;
+  hostTable[hashv].links++;
+  hostTable[hashv].hits++;
+}
+
 /*
  * add_to_resv_hash_table
  */
@@ -445,6 +495,37 @@
     }
 }
 
+void
+del_from_hostname_hash_table(const char *hostname, struct Client *client_p)
+{
+  struct Client *target_p;
+  struct Client *last_p = NULL;
+  unsigned int hashv;
+
+  if(hostname == NULL || client_p == NULL)
+    return;
+
+  hashv = hash_hostname(hostname);
+  for(target_p = (struct Client *)hostTable[hashv].list; target_p;
+      target_p = target_p->hostnext)
+  {
+    if(target_p == client_p)
+    {
+      if(last_p)
+        last_p->hostnext = client_p->hostnext;
+      else
+        hostTable[hashv].list = (void *)client_p->hostnext;
+
+      if(hostTable[hashv].links > 0)
+        hostTable[hashv].links--;
+
+      return;
+    }
+
+    last_p = target_p;
+  }
+}
+  
 /*
  * del_from_resv_hash_table()
  */
@@ -552,6 +633,25 @@
   return (NULL);
 }
 
+struct Client *
+find_hostname(const char *hostname)
+{
+  struct Client *target_p;
+  unsigned int hashv;
+
+  if(hostname == NULL)
+    return NULL;
+
+  hashv = hash_hostname(hostname);
+  for(target_p = (struct Client *)hostTable[hashv].list; target_p;
+      target_p = target_p->hostnext)
+  {
+    if(irccmp(target_p->host, hostname) == 0)
+      return target_p;
+  }
+
+  return NULL;
+}
 
 /*
  * Whats happening in this next loop ? Well, it takes a name like
@@ -784,8 +884,72 @@
   return(NULL);
 }  
 
+#ifdef FL_DEBUG
+void
+mo_hash(struct Client *source_p, struct Client *client_p, 
+        int argc,char *argv[])
+{
+  int i;
+  struct Client *target_p;
+  u_long used_count;
+  int deepest_link;
+  u_long average_link;
+  int this_link;
+  int node[11];
+
+  for(i = 0; i < 11; i++)
+    node[i] = 0;
+
+  deepest_link = used_count = this_link = average_link = 0;
+
+  sendto_one(source_p, ":%s %d %s :Hostname hash statistics",
+               me.name, RPL_STATSDEBUG, source_p->name);
+  
+  for(i = 0; i < HOST_MAX; i++)
+  {
+    this_link = 0;
+
+    for(target_p = hostTable[i].list; target_p; target_p = target_p->hostnext)
+    {
+      used_count++;
+      this_link++;
+    }
 
+    if(this_link > deepest_link)
+      deepest_link = this_link;
 
+    if(this_link >= 10)
+    {
+      int j = 0;
+      for(target_p = hostTable[i].list; target_p; target_p = target_p->hostnext) 
+      {
+        sendto_one(source_p, ":%s %d %s :Node[%d][%d] %s",
+                   me.name, RPL_STATSDEBUG, source_p->name, i, j,
+		   target_p->host);
+	j++;
+      }
 
+      this_link = 10;
+    }
 
+    node[this_link]++;
+  }
 
+  for(i = 1; i < 11; i++)
+    average_link += node[i] * i;
+    
+  sendto_one(source_p, ":%s %d %s :Hash Size: %d - Used %lu %f%% - Free %lu %f%%",
+             me.name, RPL_STATSDEBUG, source_p->name, HOST_MAX,
+	     used_count, (float)((used_count / HOST_MAX) * 100), 
+	     HOST_MAX - used_count, 
+	     (float)((float)((float)(HOST_MAX - used_count) / HOST_MAX) * 100));
+  
+  sendto_one(source_p, ":%s %d %s :Deepest Link: %d - Average  %f",
+             me.name, RPL_STATSDEBUG, source_p->name, deepest_link,
+	     (float)(average_link / used_count));
+
+  for(i = 0; i < 11; i++)
+    sendto_one(source_p, ":%s %d %s :Nodes with %d entries: %d",
+               me.name, RPL_STATSDEBUG, source_p->name, i, node[i]);
+}
+#endif
diff -urN ircd-hybrid-7/src/ircd.c ircd-hybrid-7+lmh/src/ircd.c
--- ircd-hybrid-7/src/ircd.c	Tue Jun  4 06:30:16 2002
+++ ircd-hybrid-7+lmh/src/ircd.c	Sat Jun 15 12:26:17 2002
@@ -261,6 +261,8 @@
    STRING, "File to use for ircd.conf"},
   {"klinefile",  &ConfigFileEntry.klinefile, 
    STRING, "File to use for klines.conf"},
+  {"xlinefile",  &ConfigFileEntry.xlinefile,
+   STRING, "File to use for xlines.conf"},
   {"logfile",    &logFileName, 
    STRING, "File to use for ircd.log"},
   {"pidfile",    &pidFileName,
@@ -590,6 +592,7 @@
   ConfigFileEntry.klinefile = KPATH;    /* Server kline file */
   ConfigFileEntry.dlinefile = DLPATH;   /* dline file */
   ConfigFileEntry.glinefile = GPATH;    /* gline log file */
+  ConfigFileEntry.xlinefile = XPATH;
 
   myargv = argv;
   umask(077);                /* better safe than sorry --SRB */
@@ -740,7 +743,10 @@
 
   eventAddIsh("cleanup_glines", cleanup_glines, NULL, CLEANUP_GLINES_TIME);
 
-  eventAddIsh("cleanup_tklines", cleanup_tklines, NULL, CLEANUP_TKLINES_TIME);
+  eventAddIsh("cleanup_temps_min", cleanup_temps_min, NULL, 60);
+  eventAddIsh("cleanup_temps_hour", cleanup_temps_hour, NULL, 3600);
+  eventAddIsh("cleanup_temps_day", cleanup_temps_day, NULL, 86400);
+  eventAddIsh("cleanup_temps_week", cleanup_temps_week, NULL, 604800);
 
   /* We want try_connections to be called as soon as possible now! -- adrian */
   /* No, 'cause after a restart it would cause all sorts of nick collides */
diff -urN ircd-hybrid-7/src/ircd_lexer.l ircd-hybrid-7+lmh/src/ircd_lexer.l
--- ircd-hybrid-7/src/ircd_lexer.l	Sat May 25 02:55:20 2002
+++ ircd-hybrid-7+lmh/src/ircd_lexer.l	Sat Jun 15 12:26:17 2002
@@ -181,7 +181,9 @@
 no_join_on_split   { return NO_JOIN_ON_SPLIT; }
 no_oper_flood   { return NO_OPER_FLOOD; }
 no_tilde	{ return NO_TILDE; }
-number_per_ip	{ return NUMBER_PER_IP; }
+number_per_ident	{ return NUMBER_PER_IDENT; }
+number_per_ip		{ return NUMBER_PER_IP; }
+number_per_ip_global	{ return NUMBER_PER_IP_GLOBAL; }
 oper		{ return OPERATOR; }
 oper_log        { return OPER_LOG; }
 operator	{ return OPERATOR; }
@@ -216,6 +218,7 @@
 use_anonops	{ return USE_ANONOPS; }
 use_egd 	{ return USE_EGD; }
 use_except	{ return USE_EXCEPT; }
+use_global_limits	{ return USE_GLOBAL_LIMITS; }
 use_halfops     { return USE_HALFOPS; }
 use_invex	{ return USE_INVEX; }
 use_knock	{ return USE_KNOCK; }
@@ -226,6 +229,7 @@
 vhost	{ return VHOST; }
 vhost6	{ return VHOST6; }
 warn		{ return WARN; }
+xline		{ return XLINE; }
 yes		{ return TYES; }
 
 failed_oper_notice      { return FAILED_OPER_NOTICE; }
diff -urN ircd-hybrid-7/src/ircd_parser.y ircd-hybrid-7+lmh/src/ircd_parser.y
--- ircd-hybrid-7/src/ircd_parser.y	Wed Jun 12 20:29:36 2002
+++ ircd-hybrid-7+lmh/src/ircd_parser.y	Sat Jun 15 12:26:17 2002
@@ -37,6 +37,7 @@
 #include "event.h"
 #include "s_log.h"
 #include "client.h"	/* for FLAGS_ALL only */
+#include "class.h"
 #include "irc_string.h"
 #include "ircdauth.h"
 #include "memory.h"
@@ -57,6 +58,8 @@
 
 int yyparse();
 
+static struct Class *yy_class = NULL;
+
 static struct ConfItem *yy_achead = NULL;
 static struct ConfItem *yy_aconf = NULL;
 static struct ConfItem *yy_aprev = NULL;
@@ -70,12 +73,6 @@
 
 static dlink_node *node;
 
-char  *class_name_var;
-int   class_ping_time_var;
-int   class_number_per_ip_var;
-int   class_max_number_var;
-int   class_sendq_var;
-
 static char  *listener_address;
 
 char *resv_reason;
@@ -188,7 +185,9 @@
 %token  NO_OPER_FLOOD
 %token  NO_TILDE
 %token  NUMBER
+%token  NUMBER_PER_IDENT
 %token  NUMBER_PER_IP
+%token  NUMBER_PER_IP_GLOBAL
 %token  OPERATOR
 %token  OPER_LOG
 %token  OPER_ONLY_UMODES
@@ -270,6 +269,7 @@
 %token	USE_ANONOPS
 %token  USE_EGD
 %token  USE_EXCEPT
+%token	USE_GLOBAL_LIMITS
 %token  USE_HALFOPS
 %token  USE_INVEX
 %token  USE_KNOCK
@@ -279,6 +279,7 @@
 %token  VHOST6
 %token  WARN
 %token  WARN_NO_NLINE
+%token	XLINE
 
 %type   <string>   QSTRING
 %type   <number>   NUMBER
@@ -749,7 +750,7 @@
                 oper_item;
 
 oper_item:      oper_name  | oper_user | oper_password |
-                oper_class | oper_global_kill | oper_remote |
+                oper_class | oper_global_kill | oper_remote | oper_xline |
                 oper_kline | oper_unkline | oper_gline | oper_nick_changes |
                 oper_die | oper_rehash | oper_admin | oper_rsa_public_key_file | error;
 
@@ -874,6 +875,10 @@
               |
               UNKLINE '=' TNO ';' { yy_achead->port &= ~CONF_OPER_UNKLINE; } ;
 
+oper_xline: XLINE '=' TYES ';' { yy_achead->port |= CONF_OPER_XLINE; }
+            |
+            XLINE '=' TNO ';' { yy_achead->port &= ~CONF_OPER_XLINE; };
+
 oper_gline: GLINE '=' TYES ';' { yy_achead->port |= CONF_OPER_GLINE;}
             |
             GLINE '=' TNO ';' { yy_achead->port &= ~CONF_OPER_GLINE; };
@@ -900,22 +905,14 @@
 
 class_entry:    CLASS 
   {
-    MyFree(class_name_var);
-    class_name_var = NULL;
-    class_ping_time_var = 0;
-    class_number_per_ip_var = 0;
-    class_max_number_var = 0;
-    class_sendq_var = 0;
+    yy_class = make_class();
   }
   '{' class_items '}' ';'
   {
-
-    add_class(class_name_var,class_ping_time_var,
-              class_number_per_ip_var, class_max_number_var,
-              class_sendq_var );
-
-    MyFree(class_name_var);
-    class_name_var = NULL;
+    if(yy_class->class_name)
+      add_class(yy_class);
+    else
+      free_class(yy_class);
   };
 
 class_items:    class_items class_item |
@@ -924,6 +921,8 @@
 class_item:     class_name |
                 class_ping_time |
                 class_number_per_ip |
+		class_number_per_ip_global |
+		class_number_per_ident |
                 class_connectfreq |
                 class_max_number |
                 class_sendq |
@@ -931,33 +930,42 @@
 
 class_name:     NAME '=' QSTRING ';' 
   {
-    MyFree(class_name_var);
-    DupString(class_name_var, yylval.string);
+    DupString(yy_class->class_name, yylval.string);
   };
 
 class_ping_time:        PING_TIME '=' timespec ';'
   {
-    class_ping_time_var = $3;
+    yy_class->ping_freq = $3;
   };
 
 class_number_per_ip:    NUMBER_PER_IP '=' NUMBER ';'
   {
-    class_number_per_ip_var = $3;
+    yy_class->max_local = $3;
+  };
+
+class_number_per_ip_global: NUMBER_PER_IP_GLOBAL '=' NUMBER ';'
+  {
+    yy_class->max_global = $3;
+  };
+
+class_number_per_ident: NUMBER_PER_IDENT '=' NUMBER ';'
+  {
+    yy_class->max_ident = $3;
   };
 
 class_connectfreq:     CONNECTFREQ '=' timespec ';'
   {
-    class_number_per_ip_var = $3;
+    yy_class->con_freq = $3;
   };
 
 class_max_number:       MAX_NUMBER '=' NUMBER ';'
   {
-    class_max_number_var = $3;
+    yy_class->max_total = $3;
   };
 
 class_sendq:    SENDQ '=' sizespec ';'
   {
-    class_sendq_var = $3;
+    yy_class->max_sendq = $3;
   };
 
 
@@ -1302,6 +1310,7 @@
     yy_aconf->name = NULL;
     yy_aconf->user = NULL;
     yy_aconf->host = NULL;
+    yy_aconf->port = CONF_OPER_K;
   }
   '{' shared_items '}' ';'
   {
@@ -1312,7 +1321,8 @@
 shared_items:		shared_items shared_item |
 			shared_item;
 
-shared_item:		shared_name | shared_user | error;
+shared_item:		shared_name | shared_user | shared_kline |
+                        shared_unkline | error;
 
 shared_name:		NAME '=' QSTRING ';'
   {
@@ -1340,6 +1350,14 @@
     }
   };
 
+shared_kline:  KLINE '=' TYES ';' { yy_aconf->port |= CONF_OPER_K; };
+               |
+	       KLINE '=' TNO ';' { yy_aconf->port &= ~CONF_OPER_K; };
+
+shared_unkline: UNKLINE '=' TYES ';' { yy_aconf->port |= CONF_OPER_UNKLINE; };
+                |
+		UNKLINE '=' TNO ';' { yy_aconf->port &= ~CONF_OPER_UNKLINE; };
+
 /***************************************************************************
  *  section connect
  ***************************************************************************/
@@ -1969,7 +1987,7 @@
                     general_oper_umodes |
                     general_caller_id_wait | general_default_floodcount |
                     general_min_nonwildcard |
-                    general_servlink_path |
+                    general_servlink_path | general_use_global_limits |
                     general_default_cipher_preference |
                     general_compression_level | general_client_flood |
                     general_throttle_time | general_havent_read_conf |
@@ -2331,6 +2349,23 @@
   {
     ConfigFileEntry.ping_cookie = 0;
   } ;
+
+general_use_global_limits: USE_GLOBAL_LIMITS '=' TYES ';'
+  {
+    if(ConfigFileEntry.use_global_limits == 0)
+      ilog(L_ERROR, "Ignoring config file entry 'use_global_limits = yes' "
+                    "-- can only be changed on boot");
+    else
+      ConfigFileEntry.use_global_limits = 1;
+  }
+    | USE_GLOBAL_LIMITS '=' TNO ';'
+  {
+    if(ConfigFileEntry.use_global_limits == 1)
+      ilog(L_ERROR, "Ignoring config file entry 'use_global_limits = no' "
+                    "-- can only be changed on boot");
+    else
+      ConfigFileEntry.use_global_limits = 0;
+  };
 
 general_throttle_time: THROTTLE_TIME '=' timespec ';'
 {
diff -urN ircd-hybrid-7/src/kdparse.c ircd-hybrid-7+lmh/src/kdparse.c
--- ircd-hybrid-7/src/kdparse.c	Sat May 25 00:34:48 2002
+++ ircd-hybrid-7+lmh/src/kdparse.c	Sat Jun 15 12:26:17 2002
@@ -109,6 +109,40 @@
     }
 }
 
+void
+parse_x_file(FBFILE *file)
+{
+  struct ConfItem *aconf;
+  char *reason_field = NULL;
+  char *host_field = NULL;
+  char *port_field = NULL;
+  char line[BUFSIZE];
+  char *p;
+
+  while(fbgets(line, sizeof(line), file))
+  {
+    if((p = strchr(line, '\n')))
+      *p = '\0';
+
+    if((*line == '\0') || (line[0] == '#'))
+      continue;
+
+    if((host_field = getfield(line)) == NULL)
+      continue;
+
+    if((port_field = getfield(NULL)) == NULL)
+      continue;
+
+    if((reason_field = getfield(NULL)) == NULL)
+      continue;
+
+    aconf = make_conf();
+    aconf->status = CONF_XLINE;
+    conf_add_fields(aconf, host_field, reason_field, "", port_field, NULL);
+    conf_add_x_conf(aconf);
+  }
+}
+
 /*
  * getfield
  *
diff -urN ircd-hybrid-7/src/messages.tab ircd-hybrid-7+lmh/src/messages.tab
--- ircd-hybrid-7/src/messages.tab	Wed May 22 14:52:43 2002
+++ ircd-hybrid-7+lmh/src/messages.tab	Sat Jun 15 12:26:17 2002
@@ -238,7 +238,7 @@
 /* 215 RPL_STATSILINE, */       ":%s 215 %s %c %s * %s@%s %d %s",
 /* 216 RPL_STATSKLINE, */       ":%s 216 %s %c %s * %s :%s",
 /* 217 RPL_STATSQLINE, */       ":%s 217 %s %c %s :%s",
-/* 218 RPL_STATSYLINE, */       ":%s 218 %s %c %s %d %d %d %lu",
+/* 218 RPL_STATSYLINE, */       ":%s 218 %s %c %s %d %d %d %lu %d.%d %d.%d",
 /* 219 RPL_ENDOFSTATS, */       ":%s 219 %s %s :End of /STATS report",
 /* 220 RPL_STATSPLINE, */       ":%s 220 %s %c %d %s %d :%s",
 /* 221 RPL_UMODEIS, */          ":%s 221 %s %s",
diff -urN ircd-hybrid-7/src/modules.c ircd-hybrid-7+lmh/src/modules.c
--- ircd-hybrid-7/src/modules.c	Tue Jun  4 06:30:16 2002
+++ ircd-hybrid-7+lmh/src/modules.c	Sat Jun 15 12:26:17 2002
@@ -110,6 +110,10 @@
 
 extern struct Message error_msgtab;
 
+#ifdef FL_DEBUG
+extern struct Message hash_msgtab;
+#endif
+
 void
 modules_init(void)
 {
@@ -119,6 +123,9 @@
 	mod_add_cmd(&modlist_msgtab);
 	mod_add_cmd(&modrestart_msgtab);
 	mod_add_cmd(&error_msgtab);
+#ifdef FL_DEBUG
+	mod_add_cmd(&hash_msgtab);
+#endif
 }
 
 /* mod_find_path()
diff -urN ircd-hybrid-7/src/s_conf.c ircd-hybrid-7+lmh/src/s_conf.c
--- ircd-hybrid-7/src/s_conf.c	Sat Jun 15 12:25:46 2002
+++ ircd-hybrid-7+lmh/src/s_conf.c	Sat Jun 15 12:26:17 2002
@@ -73,7 +73,8 @@
 static void     read_conf(FBFILE*);
 static void     clear_out_old_conf(void);
 static void     flush_deleted_I_P(void);
-static void     expire_tklines(dlink_list *);
+static void	add_temp_line(struct ConfItem *);
+static void     expire_temps(dlink_list *, int);
 static int 	is_attached(struct Client *client_p, struct ConfItem *aconf);
 
 FBFILE* conf_fbfile_in;
@@ -435,18 +436,40 @@
       (void)exit_client(client_p, source_p, &me, "Socket Error");
       break;
 
-    case TOO_MANY:
+    case TOO_MANY_LOCAL:
       sendto_realops_flags(FLAGS_FULL, L_ALL, 
-                           "Too many on IP for %s (%s).",
-			   get_client_name(source_p, SHOW_IP),
-			   source_p->localClient->sockhost);
+                           "Too many local connections for %s",
+			   get_client_name(source_p, SHOW_IP));
 			   
-      ilog(L_INFO,"Too many connections on IP from %s.",
-	   get_client_name(source_p, SHOW_IP));
+      ilog(L_INFO,"Too many local connections from %s",
+           get_client_name(source_p, SHOW_IP));
       
       ServerStats->is_ref++;
-      (void)exit_client(client_p, source_p, &me, 
-			"No more connections allowed on that IP" );
+      exit_client(client_p, source_p, &me, "Too many host connections (local)");
+      break;
+
+    case TOO_MANY_GLOBAL:
+      sendto_realops_flags(FLAGS_FULL, L_ALL,
+		           "Too many global connections for %s",
+			   get_client_name(source_p, SHOW_IP));
+      ilog(L_INFO, "Too many global connections from %s",
+           get_client_name(source_p, SHOW_IP));
+
+      ServerStats->is_ref++;
+      exit_client(client_p, source_p, &me,
+		  "Too many host connections (global)");
+      break;
+
+    case TOO_MANY_IDENT:
+      sendto_realops_flags(FLAGS_FULL, L_ALL,
+		           "Too many user connections for %s",
+			   get_client_name(source_p, SHOW_IP));
+      ilog(L_INFO, "Too many user connections from %s",
+           get_client_name(source_p, SHOW_IP));
+
+      ServerStats->is_ref++;
+      exit_client(client_p, source_p, &me,
+                  "Too many user connections (global)");
       break;
 
     case I_LINE_FULL:
@@ -601,18 +624,61 @@
 static 
 int attach_iline(struct Client *client_p, struct ConfItem *aconf)
 {
-  IP_ENTRY *ip_found;
-  ip_found = find_or_add_ip(&client_p->localClient->ip);
+  if(ConfigFileEntry.use_global_limits)
+  {
+    struct Client *target_p;
+    int local_count = 0;
+    int global_count = 0;
+    int ident_count = 0;
+    int unidented = 0;
+
+    if(IsConfExemptLimits(aconf))
+      return(attach_conf(client_p, aconf));
 
-  SetIpHash(client_p);
-  ip_found->count++;
+    if(*client_p->username == '~')
+      unidented = 1;
 
-  /* only check it if its non zero */
-  if ( aconf->c_class /* This should never non NULL *grin* */ &&
-       ConfConFreq(aconf) && ip_found->count > ConfConFreq(aconf))
+    for(target_p = find_hostname(client_p->host); target_p;
+        target_p = target_p->hostnext)
+    {
+      if(irccmp(client_p->host, target_p->host) != 0)
+        continue;
+
+      if(MyConnect(target_p))
+        local_count++;
+
+      global_count++;
+
+      if(unidented)
+      {
+	if(*target_p->username == '~')
+          ident_count++;
+      }
+      else if(irccmp(target_p->username, client_p->username) == 0)
+        ident_count++;
+
+      if(ConfMaxLocal(aconf) && local_count >= ConfMaxLocal(aconf))
+        return TOO_MANY_LOCAL;
+      else if(ConfMaxGlobal(aconf) && global_count >= ConfMaxGlobal(aconf))
+        return TOO_MANY_GLOBAL;
+      else if(ConfMaxIdent(aconf) && ident_count >= ConfMaxIdent(aconf))
+        return TOO_MANY_IDENT;
+    }
+  }
+  else
+  {
+    IP_ENTRY *ip_found;
+    ip_found = find_or_add_ip(&client_p->localClient->ip);
+
+    SetIpHash(client_p);
+    ip_found->count++;
+
+    /* only check it if its non zero */
+    if(aconf->c_class &&
+       ConfMaxLocal(aconf) && ip_found->count > ConfMaxLocal(aconf))
     {
       if(!IsConfExemptLimits(aconf))
-        return TOO_MANY; /* Already at maximum allowed ip#'s */
+        return TOO_MANY_LOCAL; /* Already at maximum allowed ip#'s */
       else
         {
           sendto_one(client_p,
@@ -620,6 +686,7 @@
                      me.name,client_p->name);
         }
     }
+  }
 
   return (attach_conf(client_p, aconf) );
 }
@@ -911,10 +978,10 @@
             {
               if (aconf->status & CONF_CLIENT_MASK)
                 {
-                  if (ConfLinks(aconf) > 0)
-                    --ConfLinks(aconf);
+                  if (ConfCurrUsers(aconf) > 0)
+                    --ConfCurrUsers(aconf);
                 }
-              if (ConfMaxLinks(aconf) == -1 && ConfLinks(aconf) == 0)
+              if (ConfMaxUsers(aconf) == -1 && ConfCurrUsers(aconf) == 0)
                 {
                   free_class(ClassPtr(aconf));
                   ClassPtr(aconf) = NULL;
@@ -980,7 +1047,7 @@
   if ( (aconf->status & CONF_OPERATOR) == 0 )
     {
       if ((aconf->status & CONF_CLIENT) &&
-          ConfLinks(aconf) >= ConfMaxLinks(aconf) && ConfMaxLinks(aconf) > 0)
+          ConfCurrUsers(aconf) >= ConfMaxUsers(aconf) && ConfMaxUsers(aconf) > 0)
         {
           if (!IsConfExemptLimits(aconf))
             {
@@ -1006,7 +1073,7 @@
 
   aconf->clients++;
   if (aconf->status & CONF_CLIENT_MASK)
-    ConfLinks(aconf)++;
+    ConfCurrUsers(aconf)++;
   return 0;
 }
 
@@ -1111,7 +1178,7 @@
         continue;
       if (tmp->status & CONF_OPERATOR)
         {
-          if (tmp->clients < ConfMaxLinks(tmp))
+          if (tmp->clients < ConfMaxUsers(tmp))
             return tmp;
           else
             continue;
@@ -1235,7 +1302,7 @@
  * side effects - looks for a matches on all fields
  */
 int 
-find_u_conf(char *server,char *user,char *host)
+find_u_conf(char *server,char *user,char *host, int flag)
 {
   struct ConfItem *aconf;
 
@@ -1247,8 +1314,15 @@
       if(match(aconf->name,server))
 	{
 	  if (BadPtr(aconf->user) || BadPtr(aconf->host))
-	    return YES;
-	  if(match(aconf->user,user) && match(aconf->host,host))
+	  {
+            if(aconf->port & flag)
+  	      return YES;
+	    else
+              return NO;
+	  }
+
+	  if(match(aconf->user,user) && match(aconf->host,host) &&
+             aconf->port & flag)
 	    return YES;
 
 	}
@@ -1391,7 +1465,7 @@
   ConfigFileEntry.max_targets = MAX_TARGETS_DEFAULT;
   DupString(ConfigFileEntry.servlink_path, SLPATH);
   ConfigFileEntry.egdpool_path = NULL;
-  
+
 #ifdef HAVE_LIBCRYPTO
   /* jdc -- This is our default value for a cipher.  According to the
    *        CRYPTLINK document (doc/cryptlink.txt), BF/128 must be supported
@@ -1499,6 +1573,9 @@
   if(ConfigChannel.use_anonops == -1)
     ConfigChannel.use_anonops = 0;
 
+  if(ConfigFileEntry.use_global_limits == -1)
+    ConfigFileEntry.use_global_limits = 1;
+
   GlobalSetOptions.idletime = (ConfigFileEntry.idletime * 60);
 }
 
@@ -1513,14 +1590,6 @@
 {
   (void)collapse(aconf->host);
   (void)collapse(aconf->user);
-  Debug((DEBUG_NOTICE,
-	 "Read Init: (%d) (%s) (%s) (%s) (%d) (%d)",
-	 aconf->status, 
-	 aconf->host ? aconf->host : "<NULL>",
-	 aconf->passwd ? aconf->passwd : "<NULL>",
-	 aconf->user ? aconf->user : "<NULL>",
-	 aconf->port,
-	 aconf->c_class ? ConfClassType(aconf): 0 ));
 
   aconf->next = ConfigItemList;
   ConfigItemList = aconf;
@@ -1653,40 +1722,80 @@
 void
 add_temp_kline(struct ConfItem *aconf)
 {
-  dlink_node *kill_node;
-  kill_node = make_dlink_node();
-  dlinkAdd(aconf, kill_node, &temporary_klines);
+  add_temp_line(aconf);
   aconf->flags |= CONF_FLAGS_TEMPORARY;
   add_conf_by_address(aconf->host, CONF_KILL, aconf->user, aconf);
 }
 
-/*
- * cleanup_tklines
+/* add_temp_dline
  *
- * inputs       - NONE
- * output       - NONE
- * side effects - call function to expire tklines
- *                This is an event started off in ircd.c
+ * input	- pointer to struct ConfItem
+ * output	- none
+ * side effects - added to tkline link list and address hash
  */
+void add_temp_dline(struct ConfItem *aconf)
+{
+  add_temp_line(aconf);
+  aconf->flags |= CONF_FLAGS_TEMPORARY;
+  add_conf_by_address(aconf->host, CONF_DLINE, aconf->user, aconf);
+}
+
+void
+cleanup_temps_min(void *notused)
+{
+  expire_temps(&temporary_min, TEMP_MIN);
+}
+
+void
+cleanup_temps_hour(void *notused)
+{
+  expire_temps(&temporary_hour, TEMP_HOUR);
+}
+
+void
+cleanup_temps_day(void *notused)
+{
+  expire_temps(&temporary_day, TEMP_DAY);
+}
+
 void
-cleanup_tklines(void *notused)
+cleanup_temps_week(void *notused)
+{
+  expire_temps(&temporary_week, TEMP_WEEK);
+}
+
+static void
+add_temp_line(struct ConfItem *aconf)
 {
-  expire_tklines(&temporary_klines);
+  dlink_node *m;
+
+  m = make_dlink_node();
+  
+  if(aconf->hold > CurrentTime + (10080*60))
+    dlinkAdd(aconf, m, &temporary_week);
+  else if(aconf->hold > CurrentTime + (1440*60))
+    dlinkAdd(aconf, m, &temporary_day);
+  else if(aconf->hold > CurrentTime + (60*60))
+    dlinkAdd(aconf, m, &temporary_hour);
+  else
+    dlinkAdd(aconf, m, &temporary_min);
 }
 
 /*
- * expire_tklines
+ * expire_temps
  *
- * inputs       - tkline list pointer
+ * inputs       - list pointer
+ * 		- type
  * output       - NONE
  * side effects - expire tklines
  */
 static void
-expire_tklines(dlink_list *tklist)
+expire_temps(dlink_list *tklist, int type)
 {
   dlink_node *kill_node;
   dlink_node *next_node;
   struct ConfItem *kill_ptr;
+
   for (kill_node = tklist->head; kill_node; kill_node = next_node)
     {
       kill_ptr = kill_node->data;
@@ -1695,15 +1804,48 @@
       if (kill_ptr->hold <= CurrentTime)
 	{
           /* Alert opers that a TKline expired - Hwy */
-          sendto_realops_flags(FLAGS_ALL, L_ALL,
+          if(kill_ptr->status & CONF_KILL)
+            sendto_realops_flags(FLAGS_ALL, L_ALL,
 			       "Temporary K-line for [%s@%s] expired",
 			       (kill_ptr->user) ? kill_ptr->user : "*",
 			       (kill_ptr->host) ? kill_ptr->host : "*");
 
+	  /* temp dline */
+	  else
+            sendto_realops_flags(FLAGS_ALL, L_ALL,
+			       "Temporary D-line for [%s] expired",
+			       kill_ptr->host);
+
 	  delete_one_address_conf(kill_ptr->host, kill_ptr);
 	  dlinkDelete(kill_node, tklist);
 	  free_dlink_node(kill_node);
 	}
+      
+      else if((type == TEMP_WEEK && kill_ptr->hold < CurrentTime + 10080) ||
+              (type == TEMP_DAY && kill_ptr->hold < CurrentTime + 1440) ||
+	      (type == TEMP_HOUR && kill_ptr->hold < CurrentTime + 60))
+      {
+        /* expires within the hour.. */
+        if(kill_ptr->hold < CurrentTime + (60*60))
+	{
+          dlinkDelete(kill_node, tklist);
+	  dlinkAdd(kill_ptr, kill_node, &temporary_min);
+	}
+
+	/* expires within the day */
+	else if(kill_ptr->hold < CurrentTime + (1440*60))
+	{
+          dlinkDelete(kill_node, tklist);
+	  dlinkAdd(kill_ptr, kill_node, &temporary_hour);
+	}
+
+	/* expires within the week */
+	else if(kill_ptr->hold < CurrentTime + (10080*60))
+	{
+          dlinkDelete(kill_node, tklist);
+	  dlinkAdd(kill_ptr, kill_node, &temporary_day);
+	}
+      }
     }
 }
 
@@ -1744,6 +1886,15 @@
   else
     *privs_ptr++ = 'k';
 
+  if(port & CONF_OPER_XLINE)
+  {
+    if(client_p)
+      SetOperXline(client_p);
+    *privs_ptr++ = 'X';
+  }
+  else
+    *privs_ptr++ = 'x';
+
   if(port & CONF_OPER_N)
     {
       if(client_p)
@@ -1944,6 +2095,7 @@
 {
   FBFILE *file;
   const char *filename, *kfilename, *dfilename; /* kline or conf filename */
+  const char *xfilename;
 
   conf_fbfile_in = NULL;
 
@@ -1970,6 +2122,7 @@
     /* set to 'undefined' */
     ConfigChannel.use_halfops = -1;
     ConfigChannel.use_anonops = -1;
+    ConfigFileEntry.use_global_limits = -1;
   }
   else
   {
@@ -2016,6 +2169,25 @@
 	  fbclose(file);
 	}
     }
+
+  xfilename = ConfigFileEntry.xlinefile;
+  if(irccmp(filename, xfilename) && irccmp(kfilename, xfilename))
+  {
+    if((file = fbopen(xfilename, "r")) == NULL)
+    {
+      if(cold)
+        ilog(L_ERROR, "Failed reading xline file %s", xfilename);
+      else
+        sendto_realops_flags(FLAGS_ALL, L_ALL,
+			     "Can't open %s file xlines could be missing!",
+			     xfilename);
+    }
+    else
+    {
+      parse_x_file(file);
+      fbclose(file);
+    }
+  }
 }
 
 /*
@@ -2069,7 +2241,7 @@
   assert(ClassList != NULL);
   
   for (cltmp = ClassList->next; cltmp; cltmp = cltmp->next)
-    MaxLinks(cltmp) = -1;
+    MaxUsers(cltmp) = -1;
 
   clear_out_address_conf();
   clear_special_conf(&x_conf);
@@ -2309,7 +2481,7 @@
       return;
     }
 
-  if (ConfMaxLinks(aconf) < 0)
+  if (ConfMaxUsers(aconf) < 0)
     {
       ClassPtr(aconf) = find_class(0);
       MyFree(aconf->className);
diff -urN ircd-hybrid-7/src/s_conf.c.orig ircd-hybrid-7+lmh/src/s_conf.c.orig
--- ircd-hybrid-7/src/s_conf.c.orig	Thu Jan  1 01:00:00 1970
+++ ircd-hybrid-7+lmh/src/s_conf.c.orig	Sat Jun 15 12:26:08 2002
@@ -0,0 +1,2527 @@
+/*
+ *  ircd-hybrid: an advanced Internet Relay Chat Daemon(ircd).
+ *  s_conf.c: Configuration file functions.
+ *
+ *  Copyright (C) 2002 by the past and present ircd coders, and others.
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
+ *  USA
+ *
+ *  $Id$
+ */
+
+#include "stdinc.h"
+#include "ircd_defs.h"
+#include "tools.h"
+#include "s_conf.h"
+#include "s_serv.h"
+#include "resv.h"
+#include "s_stats.h"
+#include "channel.h"
+#include "class.h"
+#include "client.h"
+#include "common.h"
+#include "event.h"
+#include "hash.h"
+#include "irc_string.h"
+#include "ircd.h"
+#include "list.h"
+#include "listener.h"
+#include "hostmask.h"
+#include "modules.h"
+#include "numeric.h"
+#include "fdlist.h"
+#include "s_bsd.h"
+#include "s_log.h"
+#include "send.h"
+#include "s_gline.h"
+#include "s_debug.h"
+#include "fileio.h"
+#include "memory.h"
+
+struct config_server_hide ConfigServerHide;
+
+extern int yyparse(); /* defined in y.tab.c */
+extern int lineno;
+extern char linebuf[];
+int scount = 0;       /* used by yyparse(), etc */
+
+#ifndef INADDR_NONE
+#define INADDR_NONE ((unsigned int) 0xffffffff)
+#endif
+
+
+/* internally defined functions */
+
+static void lookup_confhost(struct ConfItem* aconf);
+static int  SplitUserHost(struct ConfItem *aconf);
+
+static void     set_default_conf(void);
+static void     validate_conf(void);
+static void     read_conf(FBFILE*);
+static void     clear_out_old_conf(void);
+static void     flush_deleted_I_P(void);
+static void     expire_tklines(dlink_list *);
+static int 	is_attached(struct Client *client_p, struct ConfItem *aconf);
+
+FBFILE* conf_fbfile_in;
+extern char yytext[];
+
+/* address of class 0 conf */
+static struct   Class* class0;
+
+static  int     verify_access(struct Client *client_p, const char *username);
+static  int     attach_iline(struct Client *, struct ConfItem *);
+
+static void clear_special_conf(struct ConfItem **);
+
+/* usually, with hash tables, you use a prime number...
+ * but in this case I am dealing with ip addresses, not ascii strings.
+ */
+
+#define IP_HASH_SIZE 0x1000
+
+typedef struct ip_entry
+{
+#ifndef IPV6
+  u_int32_t ip;
+#else
+  struct irc_inaddr ip;
+#endif
+  int        count;
+#ifdef PACE_CONNECT
+  time_t last_attempt;
+#endif
+  struct ip_entry *next;
+} IP_ENTRY;
+
+static IP_ENTRY *ip_hash_table[IP_HASH_SIZE];
+
+static int hash_ip(struct irc_inaddr *);
+
+static IP_ENTRY *find_or_add_ip(struct irc_inaddr*);
+
+/* general conf items link list root */
+struct ConfItem* ConfigItemList = NULL;
+
+/* conf xline link list root */
+struct ConfItem        *x_conf = ((struct ConfItem *)NULL);
+
+/* conf uline link list root */
+struct ConfItem        *u_conf = ((struct ConfItem *)NULL);
+
+/*
+ * conf_dns_callback
+ * inputs	- pointer to struct ConfItem
+ *		- pointer to adns reply
+ * output	- none
+ * side effects	- called when resolver query finishes
+ * if the query resulted in a successful search, hp will contain
+ * a non-null pointer, otherwise hp will be null.
+ * if successful save hp in the conf item it was called with
+ */
+static void 
+conf_dns_callback(void* vptr, adns_answer *reply)
+{
+  struct ConfItem *aconf = (struct ConfItem *) vptr;
+
+  if (reply && reply->status == adns_s_ok)
+  {
+#ifdef IPV6
+    copy_s_addr(IN_ADDR(aconf->ipnum),
+                reply->rrs.addr->addr.inet6.sin6_addr.s6_addr);
+#else
+    copy_s_addr(IN_ADDR(aconf->ipnum),
+                reply->rrs.addr->addr.inet.sin_addr.s_addr);
+#endif
+    MyFree(reply);
+  }
+
+  MyFree(aconf->dns_query);
+  aconf->dns_query = NULL;
+}
+
+/*
+ * conf_dns_lookup - do a nameserver lookup of the conf host
+ * if the conf entry is currently doing a ns lookup do nothing, otherwise
+ * allocate a dns_query and start ns lookup.
+ */
+static void
+conf_dns_lookup(struct ConfItem* aconf)
+{
+  if (aconf->dns_query == NULL)
+    {
+      aconf->dns_query = MyMalloc(sizeof(struct DNSQuery));
+      aconf->dns_query->ptr = aconf;
+      aconf->dns_query->callback = conf_dns_callback;
+      adns_gethost(aconf->host, aconf->aftype, aconf->dns_query);
+    }
+}
+
+/*
+ * make_conf
+ *
+ * inputs	- none
+ * output	- pointer to new conf entry
+ * side effects	- none
+ */
+struct ConfItem* 
+make_conf()
+{
+  struct ConfItem* aconf;
+
+  aconf = (struct ConfItem*) MyMalloc(sizeof(struct ConfItem));
+  aconf->status       = CONF_ILLEGAL;
+  aconf->aftype       = AF_INET;
+  return (aconf);
+}
+
+/*
+ * free_conf
+ *
+ * inputs	- pointer to conf to free
+ * output	- none
+ * side effects	- crucial password fields are zeroed, conf is freed
+ */
+void 
+free_conf(struct ConfItem* aconf)
+{
+  assert(aconf != NULL);
+  if(aconf == NULL)
+    return;
+  assert(!(aconf->status & CONF_CLIENT) ||
+         (aconf->host && strcmp(aconf->host, "NOMATCH")) ||
+         (aconf->clients == -1));
+  delete_adns_queries(aconf->dns_query);
+  MyFree(aconf->host);
+  if (aconf->passwd)
+    memset(aconf->passwd, 0, strlen(aconf->passwd));
+  MyFree(aconf->passwd);
+  if (aconf->spasswd)
+    memset(aconf->spasswd, 0, strlen(aconf->spasswd));
+  MyFree(aconf->spasswd);
+  MyFree(aconf->name);
+  MyFree(aconf->className);
+  MyFree(aconf->user);
+#ifdef HAVE_LIBCRYPTO
+  if (aconf->rsa_public_key)        { RSA_free(aconf->rsa_public_key); }
+  if (aconf->rsa_public_key_file)   { MyFree(aconf->rsa_public_key_file); }
+#endif
+  MyFree((char*) aconf);
+}
+
+/*
+ * remove all conf entries from the client except those which match
+ * the status field mask.
+ */
+void
+det_confs_butmask(struct Client *client_p, int mask)
+{
+  dlink_node *dlink;
+  dlink_node *link_next;
+  struct ConfItem *aconf;
+
+  for (dlink = client_p->localClient->confs.head; dlink; dlink = link_next)
+  {
+    link_next = dlink->next;
+    aconf = dlink->data;
+
+    if ((aconf->status & mask) == 0)
+    {
+      detach_conf(client_p, aconf);
+    }
+  }
+}
+
+static struct LinkReport {
+  int conf_type;
+  int rpl_stats;
+  int conf_char;
+} report_array[] = {
+  { CONF_SERVER,           RPL_STATSCLINE, 'C'},
+  { CONF_LEAF,             RPL_STATSLLINE, 'L'},
+  { CONF_OPERATOR,         RPL_STATSOLINE, 'O'},
+  { CONF_HUB,              RPL_STATSHLINE, 'H'},
+  { 0, 0, '\0' }
+};
+
+/*
+ * report_configured_links
+ *
+ * inputs	- pointer to client to report to
+ *		- type of line to report
+ * output	- NONE
+ * side effects	-
+ */
+void 
+report_configured_links(struct Client* source_p, int mask)
+{
+  struct ConfItem*   tmp;
+  struct LinkReport* p;
+  char*              host;
+  char*              pass;
+  char*              user;
+  char*              name;
+  char*		     classname;
+  int                port;
+
+  for (tmp = ConfigItemList; tmp; tmp = tmp->next) {
+    if (tmp->status & mask)
+      {
+        for (p = &report_array[0]; p->conf_type; p++)
+          if (p->conf_type == tmp->status)
+            break;
+	    
+        if(p->conf_type == 0)
+	  return;
+
+        get_printable_conf(tmp, &name, &host, &pass, &user, &port,&classname);
+
+        if(mask & CONF_SERVER)
+          {
+            char c;
+	    char buf[20];
+	    char *s = buf;
+	    
+	    buf[0] = '\0';
+            c = p->conf_char;
+	    
+	    if (tmp->flags & CONF_FLAGS_ALLOW_AUTO_CONN)
+	      *s++ = 'A';
+	    if (tmp->flags & CONF_FLAGS_CRYPTLINK)
+	      *s++ = 'C';
+	    if (tmp->flags & CONF_FLAGS_LAZY_LINK)
+	      *s++ = 'L';
+	    if (tmp->flags & CONF_FLAGS_COMPRESSED)
+	      *s++ = 'Z';
+	    if (tmp->fakename)
+	      *s++ = 'M';
+	    
+	    if (!buf[0])
+              *s++ = '*';
+	      
+	    *s++ = '\0';
+            /* Allow admins to see actual ips */
+            if(IsOperAdmin(source_p))
+              sendto_one(source_p, form_str(p->rpl_stats), me.name,
+                         source_p->name, c,
+                         host,
+			 buf,
+                         name,
+                         port,
+                         classname,
+                         oper_flags_as_string((int)tmp->hold));
+            else
+              sendto_one(source_p, form_str(p->rpl_stats), me.name,
+                         source_p->name, c,
+                         "*@127.0.0.1",
+			 buf,
+                         name,
+                         port,
+                         classname);
+
+          }
+        else if(mask & (CONF_OPERATOR))
+          {
+            /* Don't allow non opers to see oper privs */
+            if(IsOper(source_p))
+              sendto_one(source_p, form_str(p->rpl_stats), me.name,
+                         source_p->name,
+                         p->conf_char,
+                         user, host, name,
+                         oper_privs_as_string((struct Client *)NULL,port),
+                         classname,
+                         oper_flags_as_string((int)tmp->hold));
+            else
+              sendto_one(source_p, form_str(p->rpl_stats), me.name,
+                         source_p->name, p->conf_char,
+                         user, host, name,
+                         "0",
+                         classname,
+                         "");
+          }
+        else
+          sendto_one(source_p, form_str(p->rpl_stats), me.name,
+                     source_p->name, p->conf_char,
+                     host, name, port,
+                     classname);
+      }
+  }
+}
+
+/*
+ * report_specials - report special conf entries
+ *
+ * inputs       - struct Client pointer to client to report to
+ *              - int flags type of special struct ConfItem to report
+ *              - int numeric for struct ConfItem to report
+ * output       - none
+ * side effects -
+ */
+void 
+report_specials(struct Client* source_p, int flags, int numeric)
+{
+  struct ConfItem* this_conf;
+  struct ConfItem* aconf;
+  char*            name;
+  char*            host;
+  char*            pass;
+  char*            user;
+  char*       classname;
+  int              port;
+
+  if (flags & CONF_XLINE)
+    this_conf = x_conf;
+  else if (flags & CONF_ULINE)
+    this_conf = u_conf;
+  else return;
+
+  for (aconf = this_conf; aconf; aconf = aconf->next)
+    if (aconf->status & flags)
+      {
+        get_printable_conf(aconf, &name, &host, &pass,
+                           &user, &port, &classname);
+
+        sendto_one(source_p, form_str(numeric),
+                   me.name,
+                   source_p->name,
+                   name,
+                   pass);
+      }
+}
+
+/*
+ * check_client
+ *
+ * inputs	- pointer to client
+ * output	- 0 = Success
+ * 		  NOT_AUTHORIZED (-1) = Access denied (no I line match)
+ * 		  SOCKET_ERROR   (-2) = Bad socket.
+ * 		  I_LINE_FULL    (-3) = I-line is full
+ *		  TOO_MANY       (-4) = Too many connections from hostname
+ * 		  BANNED_CLIENT  (-5) = K-lined
+ * side effects - Ordinary client access check.
+ *		  Look for conf lines which have the same
+ * 		  status as the flags passed.
+ */
+int 
+check_client(struct Client *client_p, struct Client *source_p, char *username)
+{
+  static char     sockname[HOSTLEN + 1];
+  int             i;
+ 
+  ClearAccess(source_p);
+
+  if ((i = verify_access(source_p, username)))
+    {
+      ilog(L_INFO, "Access denied: %s[%s]", source_p->name, sockname);
+    }
+
+  switch( i )
+    {
+    case SOCKET_ERROR:
+      (void)exit_client(client_p, source_p, &me, "Socket Error");
+      break;
+
+    case TOO_MANY:
+      sendto_realops_flags(FLAGS_FULL, L_ALL, 
+                           "Too many on IP for %s (%s).",
+			   get_client_name(source_p, SHOW_IP),
+			   source_p->localClient->sockhost);
+			   
+      ilog(L_INFO,"Too many connections on IP from %s.",
+	   get_client_name(source_p, SHOW_IP));
+      
+      ServerStats->is_ref++;
+      (void)exit_client(client_p, source_p, &me, 
+			"No more connections allowed on that IP" );
+      break;
+
+    case I_LINE_FULL:
+      sendto_realops_flags(FLAGS_FULL, L_ALL,
+                           "I-line is full for %s (%s).",
+			   get_client_name(source_p, SHOW_IP),
+			   source_p->localClient->sockhost);
+			   
+      ilog(L_INFO,"Too many connections from %s.",
+	   get_client_name(source_p, SHOW_IP));
+      
+      ServerStats->is_ref++;
+      (void)exit_client(client_p, source_p, &me, 
+		"No more connections allowed in your connection class" );
+      break;
+
+    case NOT_AUTHORIZED:
+    {
+      static char ipaddr[HOSTIPLEN];
+      ServerStats->is_ref++;
+      /* jdc - lists server name & port connections are on */
+      /*       a purely cosmetical change */
+      inetntop(source_p->localClient->aftype, &IN_ADDR(source_p->localClient->ip), ipaddr, HOSTIPLEN);
+      sendto_realops_flags(FLAGS_UNAUTH, L_ALL,
+			   "Unauthorised client connection from %s [%s] on [%s/%u].",
+			   get_client_name(source_p, SHOW_IP),
+			   ipaddr,
+			   source_p->localClient->listener->name,
+			   source_p->localClient->listener->port);
+			   
+      ilog(L_INFO,
+	  "Unauthorised client connection from %s on [%s/%u].",
+	  get_client_name(source_p, SHOW_IP),
+	  source_p->localClient->listener->name,
+	  source_p->localClient->listener->port);
+	  
+      (void)exit_client(client_p, source_p, &me,
+			"You are not authorised to use this server");
+      break;
+    }
+    case BANNED_CLIENT:
+      (void)exit_client(client_p,client_p, &me, "*** Banned ");
+      ServerStats->is_ref++;
+      break;
+
+    case 0:
+    default:
+      break;
+    }
+  return(i);
+}
+
+/*
+ * verify_access
+ *
+ * inputs	- pointer to client to verify
+ *		- pointer to proposed username
+ * output	- 0 if success -'ve if not
+ * side effect	- find the first (best) I line to attach.
+ */
+static int 
+verify_access(struct Client* client_p, const char* username)
+{
+  struct ConfItem* aconf;
+  struct ConfItem* gkill_conf;
+  char       non_ident[USERLEN + 1];
+
+  if (IsGotId(client_p))
+    {
+      aconf = find_address_conf(client_p->host,client_p->username,
+				&client_p->localClient->ip,
+				client_p->localClient->aftype);
+    }
+  else
+    {
+      non_ident[0] = '~';
+      strlcpy(&non_ident[1],username, USERLEN);
+      aconf = find_address_conf(client_p->host,non_ident,
+				&client_p->localClient->ip,
+				client_p->localClient->aftype);
+    }
+
+  if (aconf != NULL)
+    {
+      if (aconf->status & CONF_CLIENT)
+	{
+	  if (aconf->flags & CONF_FLAGS_REDIR)
+	    {
+	      sendto_one(client_p, form_str(RPL_REDIR), me.name, client_p->name,
+			 aconf->name ? aconf->name : "", aconf->port);
+	      return(NOT_AUTHORIZED);
+	    }
+	  if (ConfigFileEntry.glines)
+	    {
+	      if (!IsConfExemptKline(aconf))
+		{
+		  if (IsGotId(client_p))
+		    gkill_conf = find_gkill(client_p, client_p->username);
+		  else
+		    gkill_conf = find_gkill(client_p, non_ident);
+
+		  if (gkill_conf)
+		    {
+		      sendto_one(client_p, ":%s NOTICE %s :*** G-lined", me.name,
+				 client_p->name);
+		      sendto_one(client_p, ":%s NOTICE %s :*** Banned %s",
+				 me.name, client_p->name, 
+				 gkill_conf->passwd);
+		      return(BANNED_CLIENT);
+		    }
+		}
+	    }
+	  if (IsConfDoIdentd(aconf))
+	    SetNeedId(client_p);
+	  if (IsConfRestricted(aconf))
+	    SetRestricted(client_p);
+	  /* Thanks for spoof idea amm */
+	  if (IsConfDoSpoofIp(aconf))
+	    {
+	      if (IsConfSpoofNotice(aconf))
+		{
+		  sendto_realops_flags(FLAGS_ALL, L_ADMIN,
+				       "%s spoofing: %s as %s", client_p->name,
+				       client_p->host, aconf->name);
+		}
+	      strlcpy(client_p->host, aconf->name, HOSTLEN);
+	      SetIPSpoof(client_p);
+	    }
+	  return(attach_iline(client_p, aconf));
+	}
+      else if (aconf->status & CONF_KILL)
+	{
+	  if (ConfigFileEntry.kline_with_reason)
+	    {
+	      sendto_one(client_p, ":%s NOTICE %s :*** Banned %s",
+			 me.name,client_p->name,aconf->passwd);
+	    }
+	  return(BANNED_CLIENT);
+	}
+    }
+ return(NOT_AUTHORIZED);
+}
+
+/*
+ * attach_iline
+ *
+ * inputs	- client pointer
+ *		- conf pointer
+ * output	-
+ * side effects	- do actual attach
+ */
+static 
+int attach_iline(struct Client *client_p, struct ConfItem *aconf)
+{
+  IP_ENTRY *ip_found;
+  ip_found = find_or_add_ip(&client_p->localClient->ip);
+
+  SetIpHash(client_p);
+  ip_found->count++;
+
+  /* only check it if its non zero */
+  if ( aconf->c_class /* This should never non NULL *grin* */ &&
+       ConfConFreq(aconf) && ip_found->count > ConfConFreq(aconf))
+    {
+      if(!IsConfExemptLimits(aconf))
+        return TOO_MANY; /* Already at maximum allowed ip#'s */
+      else
+        {
+          sendto_one(client_p,
+       ":%s NOTICE %s :*** :I: line is full, but you have an >I: line!",
+                     me.name,client_p->name);
+        }
+    }
+
+  return (attach_conf(client_p, aconf) );
+}
+
+/* link list of free IP_ENTRY's */
+
+static IP_ENTRY *free_ip_entries;
+
+/*
+ * clear_ip_hash_table()
+ *
+ * input                - NONE
+ * output               - NONE
+ * side effects         - clear the ip hash table
+ *
+ */
+
+void 
+clear_ip_hash_table()
+{
+  void *block_IP_ENTRIES;        /* block of IP_ENTRY's */
+  IP_ENTRY *new_IP_ENTRY;        /* new IP_ENTRY being made */
+  IP_ENTRY *last_IP_ENTRY;        /* last IP_ENTRY in chain */
+  int size;
+  int n_left_to_allocate = MAXCONNECTIONS;
+
+  size = sizeof(IP_ENTRY) + (sizeof(IP_ENTRY) & (sizeof(void*) - 1) );
+
+  block_IP_ENTRIES = (void *)MyMalloc((size * n_left_to_allocate));  
+
+  free_ip_entries = (IP_ENTRY *)block_IP_ENTRIES;
+  last_IP_ENTRY = free_ip_entries;
+
+  /* *shudder* pointer arithmetic */
+  while(--n_left_to_allocate)
+    {
+      block_IP_ENTRIES = (void *)((unsigned long)block_IP_ENTRIES + 
+                        (unsigned long) size);
+      new_IP_ENTRY = (IP_ENTRY *)block_IP_ENTRIES;
+      last_IP_ENTRY->next = new_IP_ENTRY;
+      new_IP_ENTRY->next = (IP_ENTRY *)NULL;
+      last_IP_ENTRY = new_IP_ENTRY;
+    }
+  memset((void *)ip_hash_table, 0, sizeof(ip_hash_table));
+}
+
+/* 
+ * find_or_add_ip()
+ *
+ * inputs       - client_p
+ *              - name
+ *
+ * output       - pointer to an IP_ENTRY element
+ * side effects -
+ *
+ * If the ip # was not found, a new IP_ENTRY is created, and the ip
+ * count set to 0.
+ * XXX: Broken for IPv6
+ */
+
+static IP_ENTRY *
+find_or_add_ip(struct irc_inaddr *ip_in)
+{
+  int hash_index;
+  IP_ENTRY *ptr, *newptr;
+
+  for(ptr = ip_hash_table[hash_index = hash_ip(ip_in)]; ptr;
+      ptr = ptr->next)
+  {
+   if(!memcmp(&ptr->ip, ip_in, sizeof(struct irc_inaddr)))
+   {
+    return(ptr);
+   }
+  }
+  if ( (ptr = ip_hash_table[hash_index]) != (IP_ENTRY *)NULL )
+    {
+      if( free_ip_entries == (IP_ENTRY *)NULL)
+	outofmemory();
+
+      newptr = ip_hash_table[hash_index] = free_ip_entries;
+      free_ip_entries = newptr->next;
+
+      memcpy(&newptr->ip, ip_in, sizeof(struct irc_inaddr));
+      newptr->count = 0;
+#ifdef PACE_CONNECT
+      newptr->last_attempt = 0;
+#endif      
+      newptr->next = ptr;
+      return(newptr);
+    }
+
+  if( free_ip_entries == (IP_ENTRY *)NULL)
+    outofmemory();
+
+  ptr = ip_hash_table[hash_index] = free_ip_entries;
+  free_ip_entries = ptr->next;
+  memcpy(&ptr->ip, ip_in, sizeof(struct irc_inaddr));
+  ptr->count = 0;
+  ptr->next = (IP_ENTRY *)NULL;
+  return (ptr);
+}
+
+/* 
+ * remove_one_ip
+ *
+ * inputs        - unsigned long IP address value
+ * output        - NONE
+ * side effects  - ip address listed, is looked up in ip hash table
+ *                 and number of ip#'s for that ip decremented.
+ *                 if ip # count reaches 0, the IP_ENTRY is returned
+ *                 to the free_ip_enties link list.
+ * XXX: Broken for IPV6
+ */
+
+void 
+remove_one_ip(struct irc_inaddr *ip_in)
+{
+  IP_ENTRY *ptr, **lptr;
+  int hash_index = hash_ip(ip_in);
+  for (lptr = ip_hash_table+hash_index, ptr = *lptr;
+       ptr;
+       lptr=&ptr->next, ptr=*lptr)
+  {
+#ifndef IPV6
+   if (ptr->ip != PIN_ADDR(ip_in))
+    continue;
+#else
+   if (memcmp(&IN_ADDR(ptr->ip), &PIN_ADDR(ip_in),
+              sizeof(struct irc_inaddr)))
+    continue;
+#endif
+  if (ptr->count != 0)
+   ptr->count--;
+#ifndef PACE_CONNECT
+  if (ptr->count != 0)
+   continue;
+#else
+  if (ptr->count != 0 ||
+      (CurrentTime-ptr->last_attempt)<=ConfigFileEntry.throttle_time)
+   continue;
+#endif
+  *lptr = ptr->next;
+  ptr->next = free_ip_entries;
+  free_ip_entries = ptr;
+  return;
+ }
+}
+
+/*
+ * hash_ip()
+ * 
+ * input        - pointer to an irc_inaddr
+ * output       - integer value used as index into hash table
+ * side effects - hopefully, none
+ */
+
+static int 
+hash_ip(struct irc_inaddr *addr)
+{
+#ifndef IPV6
+  int hash;
+  u_int32_t ip;
+
+  ip = ntohl(PIN_ADDR(addr));
+  hash = ((ip >> 12) + ip) & (IP_HASH_SIZE-1);
+  return(hash);
+#else
+  unsigned int hash = 0;
+  char *ip = (char *) &PIN_ADDR(addr);
+
+  while (*ip)
+    { 
+      hash = (hash << 4) - (hash + (unsigned char)*ip++);
+    }
+
+  return(hash & (IP_HASH_SIZE - 1));
+#endif
+}
+
+/*
+ * count_ip_hash
+ *
+ * inputs        - pointer to counter of number of ips hashed 
+ *               - pointer to memory used for ip hash
+ * output        - returned via pointers input
+ * side effects  - NONE
+ *
+ * number of hashed ip #'s is counted up, plus the amount of memory
+ * used in the hash.
+ */
+
+void 
+count_ip_hash(int *number_ips_stored,u_long *mem_ips_stored)
+{
+  IP_ENTRY *ip_hash_ptr;
+  int i;
+
+  *number_ips_stored = 0;
+  *mem_ips_stored = 0;
+
+  for(i = 0; i < IP_HASH_SIZE ;i++)
+    {
+      ip_hash_ptr = ip_hash_table[i];
+      while(ip_hash_ptr)
+        {
+          *number_ips_stored = *number_ips_stored + 1;
+          *mem_ips_stored = *mem_ips_stored +
+             sizeof(IP_ENTRY);
+
+          ip_hash_ptr = ip_hash_ptr->next;
+        }
+    }
+}
+
+/*
+ * iphash_stats()
+ *
+ * inputs        - 
+ * output        -
+ * side effects        -
+ */
+void 
+iphash_stats(struct Client *client_p, struct Client *source_p,
+		  int parc, char *parv[],FBFILE* out)
+{
+  IP_ENTRY *ip_hash_ptr;
+  int i;
+  int collision_count;
+  char result_buf[256];
+
+  if(out == NULL)
+    sendto_one(source_p,":%s NOTICE %s :*** hash stats for iphash",
+               me.name,client_p->name);
+  else
+    {
+      (void)sprintf(result_buf,"*** hash stats for iphash\n");
+      (void)fbputs(result_buf,out);
+    }
+
+  for(i = 0; i < IP_HASH_SIZE ;i++)
+    {
+      ip_hash_ptr = ip_hash_table[i];
+
+      collision_count = 0;
+      while(ip_hash_ptr)
+        {
+          collision_count++;
+          ip_hash_ptr = ip_hash_ptr->next;
+        }
+      if(collision_count)
+        {
+          if(out == NULL)
+            {
+              sendto_one(source_p,":%s NOTICE %s :Entry %d (0x%X) Collisions %d",
+                         me.name,client_p->name,i,i,collision_count);
+            }
+          else
+            {
+              (void)sprintf(result_buf,"Entry %d (0x%X) Collisions %d\n",
+                            i,i,collision_count);
+              (void)fbputs(result_buf,out);
+            }
+        }
+    }
+}
+
+/*
+ * detach_conf
+ *
+ * inputs	- pointer to client to detach
+ * 		- pointer to conf item to detach
+ * output	- 0 for success, -1 for failure
+ * side effects	- Disassociate configuration from the client.
+ *		  Also removes a class from the list if marked for deleting.
+ */
+int 
+detach_conf(struct Client* client_p,struct ConfItem* aconf)
+{
+  dlink_node *ptr;
+
+  if(aconf == NULL)
+    return -1;
+
+  for( ptr = client_p->localClient->confs.head; ptr; ptr = ptr->next )
+    {
+      if (ptr->data == aconf)
+        {
+          if ((aconf) && (ClassPtr(aconf)))
+            {
+              if (aconf->status & CONF_CLIENT_MASK)
+                {
+                  if (ConfLinks(aconf) > 0)
+                    --ConfLinks(aconf);
+                }
+              if (ConfMaxLinks(aconf) == -1 && ConfLinks(aconf) == 0)
+                {
+                  free_class(ClassPtr(aconf));
+                  ClassPtr(aconf) = NULL;
+                }
+            }
+          if (aconf && !--aconf->clients && IsIllegal(aconf))
+            {
+              free_conf(aconf);
+            }
+	  dlinkDelete(ptr, &client_p->localClient->confs);
+          free_dlink_node(ptr);
+          return 0;
+        }
+    }
+  return -1;
+}
+
+/*
+ * is_attached
+ *
+ * inputs	- pointer to client to check
+ * 		- pointer to conf item to check
+ * output	- 1 if attached, 0 if not
+ * side effects	- 
+ */
+static int 
+is_attached(struct Client *client_p, struct ConfItem *aconf)
+{
+  dlink_node *ptr=NULL;
+
+  for (ptr = client_p->localClient->confs.head; ptr; ptr = ptr->next)
+    if (ptr->data == aconf)
+      break;
+  
+  return (ptr) ? 1 : 0;
+}
+
+/*
+ * attach_conf
+ * 
+ * inputs	- client pointer
+ * 		- conf pointer
+ * output	-
+ * side effects - Associate a specific configuration entry to a *local*
+ *                client (this is the one which used in accepting the
+ *                connection). Note, that this automatically changes the
+ *                attachment if there was an old one...
+ */
+int 
+attach_conf(struct Client *client_p,struct ConfItem *aconf)
+{
+  dlink_node *lp;
+
+  if (is_attached(client_p, aconf))
+    {
+      return 1;
+    }
+  if (IsIllegal(aconf))
+    {
+      return(NOT_AUTHORIZED);
+    }
+
+  if ( (aconf->status & CONF_OPERATOR) == 0 )
+    {
+      if ((aconf->status & CONF_CLIENT) &&
+          ConfLinks(aconf) >= ConfMaxLinks(aconf) && ConfMaxLinks(aconf) > 0)
+        {
+          if (!IsConfExemptLimits(aconf))
+            {
+              return(I_LINE_FULL); 
+            }
+          else
+            {
+              send(client_p->localClient->fd,
+                   "NOTICE FLINE :I: line is full, but you have an >I: line!\n",
+                   56, 0);
+              SetExemptLimits(client_p);
+            }
+
+        }
+    }
+
+  if(aconf->status & FLAGS2_RESTRICTED)
+    SetRestricted(client_p);
+
+  lp = make_dlink_node();
+
+  dlinkAdd(aconf, lp, &client_p->localClient->confs);
+
+  aconf->clients++;
+  if (aconf->status & CONF_CLIENT_MASK)
+    ConfLinks(aconf)++;
+  return 0;
+}
+
+/*
+ * attach_confs - Attach all possible CONF lines to a client
+ * if the name passed matches that for the conf file (for non-C/N lines) 
+ * or is an exact match (C/N lines only).  The difference in behaviour 
+ * is to stop C:*::* and N:*::*.
+ * returns count of conf entries attached if successful, 0 if none are found
+ *
+ * NOTE: this will allow C:::* and N:::* because the match mask is the
+ * conf line and not the name
+ */
+int 
+attach_confs(struct Client* client_p, const char* name, int statmask)
+{
+  struct ConfItem* tmp;
+  int              conf_counter = 0;
+  
+  for (tmp = ConfigItemList; tmp; tmp = tmp->next)
+    {
+      if ((tmp->status & statmask) && !IsIllegal(tmp) &&
+          tmp->name && match(tmp->name, name))
+        {
+          if (-1 < attach_conf(client_p, tmp))
+            ++conf_counter;
+        }
+      else if ((tmp->status & statmask) && !IsIllegal(tmp) &&
+               tmp->name && !irccmp(tmp->name, name))
+        {
+          if (-1 < attach_conf(client_p, tmp))
+            ++conf_counter;
+        }
+    }
+  return conf_counter;
+}
+
+/*
+ * attach_connect_block
+ *
+ * inputs	- pointer to server to attach
+ * 		- name of server
+ *		- hostname of server
+ * output	- true (1) if both are found, otherwise return false (0)
+ * side effects - find connect block and attach them to connecting client
+ */
+int 
+attach_connect_block(struct Client *client_p,
+		     const char* name,
+		     const char* host)
+{
+  struct ConfItem* ptr;
+
+  assert(client_p != NULL);
+  assert(host != NULL);
+  if(client_p == NULL || host == NULL)
+    return 0;
+
+  for (ptr = ConfigItemList; ptr; ptr = ptr->next)
+    {
+     if (IsIllegal(ptr))
+       continue;
+     if (ptr->status != CONF_SERVER)
+       continue;
+     if ((match(name, ptr->name) == 0) || (match(ptr->host, host) == 0))
+       continue;
+     attach_conf(client_p, ptr);
+     return -1;
+    }
+  return 0;
+}
+
+/*
+ * find_conf_exact
+ *
+ * inputs	- pointer to name to find
+ *		- pointer to username to find
+ *		- pointer to host to find
+ *		- int mask of type of conf to find
+ * output	- NULL or pointer to conf found
+ * side effects	- find a conf entry which matches the hostname
+ *		  and has the same name.
+ */
+struct ConfItem* 
+find_conf_exact(const char* name, const char* user, 
+		const char* host, int statmask)
+{
+  struct ConfItem *tmp;
+
+  for (tmp = ConfigItemList; tmp; tmp = tmp->next)
+    {
+      if (!(tmp->status & statmask) || !tmp->name || !tmp->host ||
+          irccmp(tmp->name, name))
+        continue;
+      /*
+      ** Accept if the *real* hostname (usually sockethost)
+      ** socket host) matches *either* host or name field
+      ** of the configuration.
+      */
+      if (!match(tmp->host, host) || !match(tmp->user,user)
+          || irccmp(tmp->name, name) )
+        continue;
+      if (tmp->status & CONF_OPERATOR)
+        {
+          if (tmp->clients < ConfMaxLinks(tmp))
+            return tmp;
+          else
+            continue;
+        }
+      else
+        return tmp;
+    }
+  return NULL;
+}
+
+/*
+ * find_conf_name
+ *
+ * inputs	- pointer to conf link list to search
+ *		- pointer to name to find
+ *		- int mask of type of conf to find
+ * output	- NULL or pointer to conf found
+ * side effects	- find a conf entry which matches the name
+ *		  and has the given mask.
+ */
+struct ConfItem* 
+find_conf_name(dlink_list *list, const char* name, int statmask)
+{
+  dlink_node *ptr;
+  struct ConfItem* aconf;
+  
+  for (ptr = list->head; ptr; ptr = ptr->next)
+    {
+      aconf = ptr->data;
+      if ((aconf->status & statmask) && aconf->name && 
+          (!irccmp(aconf->name, name) || match(aconf->name, name)))
+        return aconf;
+    }
+  return NULL;
+}
+
+
+/*
+ * find_conf_by_name
+ *
+ * inputs	- pointer to name to match on
+ *		- int mask of type of conf to find
+ * output	- NULL or pointer to conf found
+ * side effects	- find a conf entry which matches the name
+ *		  and has the given mask.
+ *
+ */
+struct ConfItem* 
+find_conf_by_name(const char* name, int status)
+{
+  struct ConfItem* conf;
+  assert(name != NULL);
+  if(name == NULL)
+    return NULL;
+  for (conf = ConfigItemList; conf; conf = conf->next)
+    {
+      if (conf->status == status && conf->name &&
+          match(name, conf->name))
+        return conf;
+    }
+  return NULL;
+}
+
+/*
+ * find_conf_by_host
+ *
+ * inputs	- pointer to hostname to match on
+ *		- int mask of type of conf to find
+ * output	- NULL or pointer to conf found
+ * side effects	- find a conf entry which matches the host
+ *		  and has the given mask.
+ *
+ */
+struct ConfItem* 
+find_conf_by_host(const char* host, int status)
+{
+  struct ConfItem* conf;
+  assert(host != NULL);
+  if(host == NULL)
+    return NULL;
+  for (conf = ConfigItemList; conf; conf = conf->next)
+    {
+      if (conf->status == status && conf->host &&
+          match(host, conf->host))
+        return conf;
+    }
+  return NULL;
+}
+
+/*
+ * find_x_conf
+ *
+ * inputs       - pointer to char string to find
+ * output       - NULL or pointer to found struct ConfItem
+ * side effects - looks for a match on name field
+ */
+struct ConfItem *
+find_x_conf(char *to_find)
+{
+  struct ConfItem *aconf;
+
+  for (aconf = x_conf; aconf; aconf = aconf->next)
+    {
+      if (BadPtr(aconf->name))
+          continue;
+
+      if(match_esc(aconf->name,to_find))
+        return(aconf);
+
+    }
+  return(NULL);
+}
+
+/*
+ * find_u_conf
+ *
+ * inputs       - pointer to servername
+ *		- pointer to user of oper
+ *		- pointer to host of oper
+ * output       - NULL or pointer to found struct ConfItem
+ * side effects - looks for a matches on all fields
+ */
+int 
+find_u_conf(char *server,char *user,char *host)
+{
+  struct ConfItem *aconf;
+
+  for (aconf = u_conf; aconf; aconf = aconf->next)
+    {
+      if (BadPtr(aconf->name))
+          continue;
+
+      if(match(aconf->name,server))
+	{
+	  if (BadPtr(aconf->user) || BadPtr(aconf->host))
+	    return YES;
+	  if(match(aconf->user,user) && match(aconf->host,host))
+	    return YES;
+
+	}
+    }
+  return NO;
+}
+
+
+/*
+ * clear_special_conf
+ * 
+ * inputs       - pointer to pointer of root of special conf link list
+ * output       - none
+ * side effects - clears given special conf lines
+ */
+static void 
+clear_special_conf(struct ConfItem **this_conf)
+{
+  struct ConfItem *aconf;
+  struct ConfItem *next_aconf;
+
+  for (aconf = *this_conf; aconf; aconf = next_aconf)
+    {
+      next_aconf = aconf->next;
+      free_conf(aconf);
+    }
+  *this_conf = (struct ConfItem *)NULL;
+  return;
+}
+
+/*
+ * rehash
+ *
+ * Actual REHASH service routine. Called with sig == 0 if it has been called
+ * as a result of an operator issuing this command, else assume it has been
+ * called as a result of the server receiving a HUP signal.
+ */
+int rehash(int sig)
+{
+  if (sig)
+    {
+      sendto_realops_flags(FLAGS_ALL, L_ALL,
+			   "Got signal SIGHUP, reloading ircd conf. file");
+    }
+
+  restart_resolver();
+  /* don't close listeners until we know we can go ahead with the rehash */
+  read_conf_files(NO);
+
+  if (ServerInfo.description != NULL)
+    {
+      strlcpy(me.info, ServerInfo.description, REALLEN);
+    }
+
+  flush_deleted_I_P();
+  check_klines();
+  return 0;
+}
+
+/*
+ * set_default_conf()
+ *
+ * inputs	- NONE
+ * output	- NONE
+ * side effects	- Set default values here.
+ *		  This is called **PRIOR** to parsing the
+ *		  configuration file.  If you want to do some validation
+ *		  of values later, put them in validate_conf().
+ */
+
+#define YES     1
+#define NO      0
+#define UNSET  -1
+
+static void 
+set_default_conf(void)
+{
+  class0 = find_class("default");       /* which one is the default class ? */
+
+#ifdef HAVE_LIBCRYPTO
+  ServerInfo.rsa_private_key = NULL;
+  ServerInfo.rsa_private_key_file = NULL;
+#endif
+
+  /* ServerInfo.name is not rehashable */
+  /* ServerInfo.name = ServerInfo.name; */
+  ServerInfo.description = NULL;
+  DupString(ServerInfo.network_name, NETWORK_NAME_DEFAULT);
+  DupString(ServerInfo.network_desc, NETWORK_DESC_DEFAULT);
+
+  memset(&ServerInfo.ip, 0, sizeof(ServerInfo.ip));
+  ServerInfo.specific_ipv4_vhost = 0;
+  memset(&ServerInfo.ip6, 0, sizeof(ServerInfo.ip6));
+  ServerInfo.specific_ipv6_vhost = 0;
+
+  ServerInfo.max_clients = MAX_CLIENTS;  /* XXX - these don't seem to */
+  ServerInfo.max_buffer = MAX_BUFFER;    /*       actually do anything! */
+  /* Don't reset hub, as that will break lazylinks */
+  /* ServerInfo.hub = NO; */
+  ServerInfo.dns_host.sin_addr.s_addr = 0;
+  ServerInfo.dns_host.sin_port = 0;
+  AdminInfo.name = NULL;
+  AdminInfo.email = NULL;
+  AdminInfo.description = NULL;
+
+  set_log_level(L_NOTICE);
+
+  ConfigFileEntry.failed_oper_notice = YES;
+  ConfigFileEntry.anti_nick_flood = NO;
+  ConfigFileEntry.max_nick_time = 20;
+  ConfigFileEntry.max_nick_changes = 5;
+  ConfigFileEntry.max_accept = 20;
+  ConfigFileEntry.anti_spam_exit_message_time = 0;
+  ConfigFileEntry.ts_warn_delta = TS_WARN_DELTA_DEFAULT;
+  ConfigFileEntry.ts_max_delta = TS_MAX_DELTA_DEFAULT;
+  ConfigFileEntry.kline_with_reason = YES;
+  ConfigFileEntry.client_exit = YES;
+  ConfigFileEntry.kline_with_connection_closed = NO;
+  ConfigFileEntry.warn_no_nline = YES;
+  ConfigFileEntry.non_redundant_klines = YES;
+  ConfigFileEntry.stats_o_oper_only = NO;
+  ConfigFileEntry.stats_k_oper_only = 1; /* masked */
+  ConfigFileEntry.stats_i_oper_only = 1; /* masked */
+  ConfigFileEntry.stats_P_oper_only = NO;
+  ConfigFileEntry.pace_wait = 10;
+  ConfigFileEntry.caller_id_wait = 60;
+  ConfigFileEntry.pace_wait_simple = 1;
+  ConfigFileEntry.short_motd = NO;
+  ConfigFileEntry.no_oper_flood = NO;
+  ConfigFileEntry.fname_userlog[0] = '\0';
+  ConfigFileEntry.fname_foperlog[0] = '\0';
+  ConfigFileEntry.fname_operlog[0] = '\0';
+  ConfigFileEntry.glines = NO;
+  ConfigFileEntry.use_egd = NO;
+  /* don't reset msglocale setting -- we'd overwrite then env string */
+  ConfigFileEntry.gline_time = 12 * 3600;
+  ConfigFileEntry.idletime = 0;
+  ConfigFileEntry.dots_in_ident = 0;
+  ConfigFileEntry.maximum_links = MAXIMUM_LINKS_DEFAULT;
+  ConfigFileEntry.max_targets = MAX_TARGETS_DEFAULT;
+  DupString(ConfigFileEntry.servlink_path, SLPATH);
+  ConfigFileEntry.egdpool_path = NULL;
+  
+#ifdef HAVE_LIBCRYPTO
+  /* jdc -- This is our default value for a cipher.  According to the
+   *        CRYPTLINK document (doc/cryptlink.txt), BF/128 must be supported
+   *        under all circumstances if cryptlinks are enabled.  So,
+   *        this will be our default.
+   *
+   *        NOTE: I apologise for the hard-coded value of "1" (BF/128).
+   *              This should be moved into a find_cipher() routine.
+   */
+  ConfigFileEntry.default_cipher_preference = &CipherTable[1];
+#endif
+#ifdef HAVE_LIBZ
+  ConfigFileEntry.compression_level = 0;
+#endif
+
+  ConfigFileEntry.oper_umodes = FLAGS_LOCOPS | FLAGS_SERVNOTICE |
+    FLAGS_OPERWALL | FLAGS_WALLOP;
+  ConfigFileEntry.oper_only_umodes = FLAGS_DEBUG;
+  ConfigFileEntry.throttle_time = 10;
+
+  ConfigChannel.vchans_oper_only = NO;
+
+  ConfigChannel.use_except  = YES;
+  ConfigChannel.use_invex   = YES;
+  ConfigChannel.use_knock   = YES;
+  ConfigChannel.use_vchans = NO;
+  ConfigChannel.knock_delay = 300;
+  ConfigChannel.knock_delay_channel = 60;
+  ConfigChannel.max_chans_per_user = 15;
+  ConfigChannel.max_bans = 25;
+
+  /* 60 * 30 = 1800 = 30 minutes */
+  ConfigChannel.persist_time = 1800;
+
+  ConfigChannel.default_split_user_count = 0;
+  ConfigChannel.default_split_server_count = 0;
+  ConfigChannel.no_join_on_split = NO;
+  ConfigChannel.no_create_on_split = NO;
+
+  ConfigServerHide.flatten_links = 0;
+  ConfigServerHide.hide_servers = 0;
+  ConfigServerHide.disable_remote = 0;
+  ConfigServerHide.links_delay = 300;
+  ConfigServerHide.hidden = 0;
+  ConfigServerHide.disable_hidden = 0;
+
+  ConfigFileEntry.min_nonwildcard = 4;
+  ConfigFileEntry.default_floodcount = 8;
+  ConfigFileEntry.client_flood = CLIENT_FLOOD_DEFAULT;
+}
+#undef YES
+#undef NO
+
+/*
+ * read_conf() 
+ *
+ *
+ * inputs       - file descriptor pointing to config file to use
+ * output       - None
+ * side effects	- Read configuration file.
+ */
+static void 
+read_conf(FBFILE* file)
+{
+  scount = lineno = 0;
+
+  set_default_conf(); /* Set default values prior to conf parsing */
+  yyparse();          /* Load the values from the conf */
+  validate_conf();    /* Check to make sure some values are still okay. */
+                      /* Some global values are also loaded here. */
+  check_class();      /* Make sure classes are valid */
+}
+
+static void 
+validate_conf(void)
+{
+  if(ConfigFileEntry.ts_warn_delta < TS_WARN_DELTA_MIN)
+    ConfigFileEntry.ts_warn_delta = TS_WARN_DELTA_DEFAULT;
+
+  if(ConfigFileEntry.ts_max_delta < TS_MAX_DELTA_MIN)
+    ConfigFileEntry.ts_max_delta = TS_MAX_DELTA_DEFAULT;
+
+  if(ConfigFileEntry.servlink_path == NULL)
+    DupString(ConfigFileEntry.servlink_path, SLPATH);
+
+  if(ServerInfo.network_name == NULL)
+    DupString(ServerInfo.network_name,NETWORK_NAME_DEFAULT);
+
+  if(ServerInfo.network_desc == NULL)
+    DupString(ServerInfo.network_desc,NETWORK_DESC_DEFAULT);
+
+  if ((ConfigFileEntry.client_flood < CLIENT_FLOOD_MIN) ||
+      (ConfigFileEntry.client_flood > CLIENT_FLOOD_MAX))
+     ConfigFileEntry.client_flood = CLIENT_FLOOD_MAX;
+
+  /* Hasn't been set yet, so set it now */
+  if(ConfigChannel.use_halfops == -1)
+#ifdef HALFOPS
+    ConfigChannel.use_halfops = 1;
+#else
+    ConfigChannel.use_halfops = 0;
+#endif
+
+  /* hasnt been set, disable it by default */
+  if(ConfigChannel.use_anonops == -1)
+    ConfigChannel.use_anonops = 0;
+
+  GlobalSetOptions.idletime = (ConfigFileEntry.idletime * 60);
+}
+
+/*
+ * conf_add_conf
+ * Inputs	- ConfItem
+ * Output	- none
+ * Side effects	- add given conf to link list
+ */
+void 
+conf_add_conf(struct ConfItem *aconf)
+{
+  (void)collapse(aconf->host);
+  (void)collapse(aconf->user);
+  Debug((DEBUG_NOTICE,
+	 "Read Init: (%d) (%s) (%s) (%s) (%d) (%d)",
+	 aconf->status, 
+	 aconf->host ? aconf->host : "<NULL>",
+	 aconf->passwd ? aconf->passwd : "<NULL>",
+	 aconf->user ? aconf->user : "<NULL>",
+	 aconf->port,
+	 aconf->c_class ? ConfClassType(aconf): 0 ));
+
+  aconf->next = ConfigItemList;
+  ConfigItemList = aconf;
+}
+
+/*
+ * SplitUserHost
+ *
+ * inputs	- struct ConfItem pointer
+ * output	- return 1/0 true false or -1 for error
+ * side effects - splits user@host found in a name field of conf given
+ *		  stuff the user into ->user and the host into ->host
+ */
+static int 
+SplitUserHost(struct ConfItem *aconf)
+{
+  char *p;
+  char *new_user;
+  char *new_host;
+
+  if ( (p = strchr(aconf->host, '@')) )
+    {
+      *p = '\0';
+      DupString(new_user, aconf->host);
+      MyFree(aconf->user);
+      aconf->user = new_user;
+      p++;
+      DupString(new_host,p);
+      MyFree(aconf->host);
+      aconf->host = new_host;
+    }
+  else
+    {
+      DupString(aconf->user, "*");
+    }
+  return(1);
+}
+
+/*
+ * lookup_confhost - start DNS lookups of all hostnames in the conf
+ * line and convert an IP addresses in a.b.c.d number for to IP#s.
+ *
+ */
+static void 
+lookup_confhost(struct ConfItem* aconf)
+{
+  if (BadPtr(aconf->host) || BadPtr(aconf->name))
+    {
+      ilog(L_ERROR, "Host/server name error: (%s) (%s)",
+          aconf->host, aconf->name);
+      return;
+    }
+
+  if (strchr(aconf->host, '*') || strchr(aconf->host, '?'))
+    return;
+  /*
+  ** Do name lookup now on hostnames given and store the
+  ** ip numbers in conf structure.
+  */
+  if (inetpton(DEF_FAM, aconf->host, &IN_ADDR(aconf->ipnum)) <= 0)
+    {
+      conf_dns_lookup(aconf);
+    }
+}
+
+/*
+ * conf_connect_allowed (untested)
+ */
+int 
+conf_connect_allowed(struct irc_inaddr *addr, int aftype)
+{
+#ifdef PACE_CONNECT
+  IP_ENTRY *ip_found;
+#endif
+  struct ConfItem *aconf = find_dline(addr, aftype);
+ 
+  /* DLINE exempt also gets you out of static limits/pacing... */
+  if (aconf && (aconf->status & CONF_EXEMPTDLINE))
+    return 0;
+ 
+  if (aconf)
+    return BANNED_CLIENT;
+
+#ifdef PACE_CONNECT
+  ip_found = find_or_add_ip(addr);
+  if ((CurrentTime - ip_found->last_attempt) <
+      ConfigFileEntry.throttle_time)
+    {
+      ip_found->last_attempt = CurrentTime;
+      ip_found->count--;
+      return TOO_FAST;
+    }
+  ip_found->last_attempt = CurrentTime;
+#endif
+  return 0;
+}
+
+/*
+ * find_kill
+ *
+ * inputs	- pointer to client structure
+ * output	- pointer to struct ConfItem if found
+ * side effects	- See if this user is klined already,
+ *		  and if so, return struct ConfItem pointer
+ */
+struct ConfItem *
+find_kill(struct Client* client_p)
+{
+  struct ConfItem *aconf;
+  assert(client_p != NULL);
+  if(client_p == NULL)
+    return NULL;
+  aconf = find_address_conf(client_p->host, client_p->username,
+			    &client_p->localClient->ip,
+			    client_p->localClient->aftype);
+  if (aconf == NULL)
+    return aconf;
+  if(aconf->status & CONF_KILL)
+    return aconf;
+  return NULL;
+}
+
+/* add_temp_kline
+ *
+ * inputs        - pointer to struct ConfItem
+ * output        - none
+ * Side effects  - links in given struct ConfItem into 
+ *                 temporary kline link list
+ */
+void
+add_temp_kline(struct ConfItem *aconf)
+{
+  dlink_node *kill_node;
+  kill_node = make_dlink_node();
+  dlinkAdd(aconf, kill_node, &temporary_klines);
+  aconf->flags |= CONF_FLAGS_TEMPORARY;
+  add_conf_by_address(aconf->host, CONF_KILL, aconf->user, aconf);
+}
+
+/*
+ * cleanup_tklines
+ *
+ * inputs       - NONE
+ * output       - NONE
+ * side effects - call function to expire tklines
+ *                This is an event started off in ircd.c
+ */
+void
+cleanup_tklines(void *notused)
+{
+  expire_tklines(&temporary_klines);
+}
+
+/*
+ * expire_tklines
+ *
+ * inputs       - tkline list pointer
+ * output       - NONE
+ * side effects - expire tklines
+ */
+static void
+expire_tklines(dlink_list *tklist)
+{
+  dlink_node *kill_node;
+  dlink_node *next_node;
+  struct ConfItem *kill_ptr;
+  for (kill_node = tklist->head; kill_node; kill_node = next_node)
+    {
+      kill_ptr = kill_node->data;
+      next_node = kill_node->next;
+
+      if (kill_ptr->hold <= CurrentTime)
+	{
+          /* Alert opers that a TKline expired - Hwy */
+          sendto_realops_flags(FLAGS_ALL, L_ALL,
+			       "Temporary K-line for [%s@%s] expired",
+			       (kill_ptr->user) ? kill_ptr->user : "*",
+			       (kill_ptr->host) ? kill_ptr->host : "*");
+
+	  delete_one_address_conf(kill_ptr->host, kill_ptr);
+	  dlinkDelete(kill_node, tklist);
+	  free_dlink_node(kill_node);
+	}
+    }
+}
+
+/*
+ * oper_privs_as_string
+ *
+ * inputs        - pointer to client_p or NULL
+ * output        - pointer to static string showing oper privs
+ * side effects  -
+ * return as string, the oper privs as derived from port
+ * also, set the oper privs if given client_p non NULL
+ */
+
+char *
+oper_privs_as_string(struct Client *client_p,int port)
+{
+  static char privs_out[16];
+  char *privs_ptr;
+
+  privs_ptr = privs_out;
+  *privs_ptr = '\0';
+
+  if(port & CONF_OPER_GLINE)
+    {
+      if(client_p)
+        SetOperGline(client_p);
+      *privs_ptr++ = 'G';
+    }
+  else
+    *privs_ptr++ = 'g';
+
+  if(port & CONF_OPER_K)
+    {
+      if(client_p)
+        SetOperK(client_p);
+      *privs_ptr++ = 'K';
+    }
+  else
+    *privs_ptr++ = 'k';
+
+  if(port & CONF_OPER_N)
+    {
+      if(client_p)
+        SetOperN(client_p);
+      *privs_ptr++ = 'N';
+    }
+
+  if(port & CONF_OPER_GLOBAL_KILL)
+    {
+      if(client_p)
+        SetOperGlobalKill(client_p);
+      *privs_ptr++ = 'O';
+    }
+  else
+    *privs_ptr++ = 'o';
+
+  if(port & CONF_OPER_REMOTE)
+    {
+      if(client_p)
+        SetOperRemote(client_p);
+      *privs_ptr++ = 'R';
+    }
+  else
+    *privs_ptr++ = 'r';
+  
+  if(port & CONF_OPER_UNKLINE)
+    {
+      if(client_p)
+        SetOperUnkline(client_p);
+      *privs_ptr++ = 'U';
+    }
+  else
+    *privs_ptr++ = 'u';
+
+  if(port & CONF_OPER_REHASH)
+    {
+      if(client_p)
+        SetOperRehash(client_p);
+      *privs_ptr++ = 'H';
+    }
+  else
+    *privs_ptr++ = 'h';
+
+  if(port & CONF_OPER_DIE)
+    {
+      if(client_p)
+        SetOperDie(client_p);
+      *privs_ptr++ = 'D';
+    }
+  else
+    *privs_ptr++ = 'd';
+
+  if (port & CONF_OPER_ADMIN)
+    {
+      if (client_p)
+	SetOperAdmin(client_p);
+      *privs_ptr++ = 'A';
+    }
+  else
+    *privs_ptr++ = 'a';
+  
+  *privs_ptr = '\0';
+
+  return(privs_out);
+}
+
+
+/* oper_flags_as_string
+ *
+ * inputs        - oper flags as bit mask
+ * output        - oper flags as as string
+ * side effects -
+ *
+ */
+char *
+oper_flags_as_string(int flags)
+{
+  /* This MUST be extended if we add any more modes... -Hwy */
+  static char flags_out[18];
+  char *flags_ptr;
+
+  flags_ptr = flags_out;
+  *flags_ptr = '\0';
+
+  if(flags & FLAGS_INVISIBLE)
+    *flags_ptr++ = 'i';
+  if(flags & FLAGS_WALLOP)
+    *flags_ptr++ = 'w';
+  if(flags & FLAGS_SERVNOTICE)
+    *flags_ptr++ = 's';
+  if(flags & FLAGS_CCONN)
+    *flags_ptr++ = 'c';
+  if(flags & FLAGS_REJ)
+    *flags_ptr++ = 'r';
+  if(flags & FLAGS_SKILL)
+    *flags_ptr++ = 'k';
+  if(flags & FLAGS_FULL)
+    *flags_ptr++ = 'f';
+  if(flags & FLAGS_SPY)
+    *flags_ptr++ = 'y';
+  if(flags & FLAGS_DEBUG)
+    *flags_ptr++ = 'd';
+  if(flags & FLAGS_NCHANGE)
+    *flags_ptr++ = 'n';
+  if(flags & FLAGS_ADMIN)
+    *flags_ptr++ = 'a';
+  if(flags & FLAGS_EXTERNAL)
+    *flags_ptr++ = 'x';
+  if(flags & FLAGS_UNAUTH)
+    *flags_ptr++ = 'u';
+  if(flags & FLAGS_BOTS)
+    *flags_ptr++ = 'b';
+  if(flags & FLAGS_LOCOPS)
+    *flags_ptr++ = 'l';
+  if(flags & FLAGS_CALLERID)
+    *flags_ptr++ = 'g';
+  *flags_ptr = '\0';
+
+  return(flags_out);
+}
+
+
+/* const char* get_oper_name(struct Client *client_p)
+ * Input: A client to find the active oper{} name for.
+ * Output: The nick!user@host{oper} of the oper.
+ *         "oper" is server name for remote opers
+ * Side effects: None.
+ */
+char*
+get_oper_name(struct Client *client_p)
+{
+  dlink_node *cnode;
+
+  /* +5 for !,@,{,} and null */
+  static char buffer[NICKLEN+USERLEN+HOSTLEN+HOSTLEN+5];
+
+  if (MyConnect(client_p))
+    {
+      for (cnode=client_p->localClient->confs.head; cnode; cnode=cnode->next)
+	if (((struct ConfItem*)cnode->data)->status & CONF_OPERATOR)
+	  {
+	    ircsprintf(buffer, "%s!%s@%s{%s}", client_p->name,
+		       client_p->username, client_p->host,
+		       ((struct ConfItem*)cnode->data)->name);
+	    return buffer;
+	  }
+      /* Probably should assert here for now. If there is an oper out there 
+       * with no oper{} conf attached, it would be good for us to know...
+       */
+      assert(0); /* Oper without oper conf! */
+    }
+  ircsprintf(buffer, "%s!%s@%s{%s}", client_p->name,
+	     client_p->username, client_p->host, client_p->servptr->name);
+  return buffer;
+}
+
+/*
+ * get_printable_conf
+ *
+ * inputs        - struct ConfItem
+ *
+ * output         - name 
+ *                - host
+ *                - pass
+ *                - user
+ *                - port
+ *
+ * side effects        -
+ * Examine the struct struct ConfItem, setting the values
+ * of name, host, pass, user to values either
+ * in aconf, or "<NULL>" port is set to aconf->port in all cases.
+ */
+
+void 
+get_printable_conf(struct ConfItem *aconf, char **name, char **host,
+                           char **pass, char **user,int *port,char **classname)
+{
+  static  char        null[] = "<NULL>";
+  static  char        zero[] = "default";
+
+  *name = BadPtr(aconf->name) ? null : aconf->name;
+  *host = BadPtr(aconf->host) ? null : aconf->host;
+  *pass = BadPtr(aconf->passwd) ? null : aconf->passwd;
+  *user = BadPtr(aconf->user) ? null : aconf->user;
+  *classname = BadPtr(aconf->className) ? zero : aconf->className;
+  *port = (int)aconf->port;
+}
+
+/*
+ * read_conf_files
+ *
+ * inputs       - cold start YES or NO
+ * output       - none
+ * side effects - read all conf files needed, ircd.conf kline.conf etc.
+ */
+void 
+read_conf_files(int cold)
+{
+  FBFILE *file;
+  const char *filename, *kfilename, *dfilename; /* kline or conf filename */
+
+  conf_fbfile_in = NULL;
+
+  filename = get_conf_name(CONF_TYPE);
+
+  if ((conf_fbfile_in = fbopen(filename,"r")) == NULL)
+    {
+      if(cold)
+        {
+          ilog(L_CRIT, "Failed in reading configuration file %s", filename);
+          exit(-1);
+        }
+      else
+        {
+          sendto_realops_flags(FLAGS_ALL, L_ALL,
+			       "Can't open file '%s' - aborting rehash!",
+			       filename );
+          return;
+        }
+    }
+
+  if (cold)
+  {
+    /* set to 'undefined' */
+    ConfigChannel.use_halfops = -1;
+    ConfigChannel.use_anonops = -1;
+  }
+  else
+  {
+    clear_out_old_conf();
+  }
+
+  read_conf(conf_fbfile_in);
+  fbclose(conf_fbfile_in);
+
+  kfilename = get_conf_name(KLINE_TYPE);
+  if (irccmp(filename, kfilename))
+    {
+      if((file = fbopen(kfilename,"r")) == NULL)
+        {
+	  if (cold)
+	    ilog(L_ERROR, "Failed reading kline file %s", filename);
+	  else
+	    sendto_realops_flags(FLAGS_ALL, L_ALL,
+				 "Can't open %s file klines could be missing!",
+				 kfilename);
+	}
+      else
+	{
+	  parse_k_file(file);
+	  fbclose(file);
+	}
+    }
+
+  dfilename = get_conf_name(DLINE_TYPE);
+  if (irccmp(filename, dfilename) && irccmp(kfilename, dfilename))
+    {
+      if ((file = fbopen(dfilename,"r")) == NULL)
+	{
+	  if(cold)
+	    ilog(L_ERROR, "Failed reading dline file %s", dfilename);
+	  else
+	    sendto_realops_flags(FLAGS_ALL, L_ALL,
+				 "Can't open %s file dlines could be missing!",
+				 dfilename);
+	}
+      else
+	{
+	  parse_d_file(file);
+	  fbclose(file);
+	}
+    }
+}
+
+/*
+ * clear_out_old_conf
+ *
+ * inputs       - none
+ * output       - none
+ * side effects - Clear out the old configuration
+ */
+static 
+void clear_out_old_conf(void)
+{
+  struct ConfItem **tmp = &ConfigItemList;
+  struct ConfItem *tmp2;
+  struct Class    *cltmp;
+
+  /*
+   * We only need to free anything allocated by yyparse() here.
+   * Reseting structs, etc, is taken care of by set_default_conf().
+   */
+  while ((tmp2 = *tmp))
+  {
+    if (tmp2->clients)
+    {
+      /*
+       ** Configuration entry is still in use by some
+       ** local clients, cannot delete it--mark it so
+       ** that it will be deleted when the last client
+       ** exits...
+       */
+      if (!(tmp2->status & CONF_CLIENT))
+      {
+        *tmp = tmp2->next;
+        tmp2->next = NULL;
+      }
+      else
+        tmp = &tmp2->next;
+      tmp2->status |= CONF_ILLEGAL;
+    }
+    else
+    {
+      *tmp = tmp2->next;
+      free_conf(tmp2);
+    }
+  }
+
+  /*
+   * don't delete the class table, rather mark all entries
+   * for deletion. The table is cleaned up by check_class. - avalon
+   */
+  assert(ClassList != NULL);
+  
+  for (cltmp = ClassList->next; cltmp; cltmp = cltmp->next)
+    MaxLinks(cltmp) = -1;
+
+  clear_out_address_conf();
+  clear_special_conf(&x_conf);
+  clear_special_conf(&u_conf);
+
+  /* clean out module paths */
+#ifndef STATIC_MODULES
+  mod_clear_paths();
+#endif
+
+  /* clean out ServerInfo */
+  MyFree(ServerInfo.description);
+  ServerInfo.description = NULL;
+  MyFree(ServerInfo.network_name);
+  ServerInfo.network_name = NULL;
+  MyFree(ServerInfo.network_desc);
+  ServerInfo.network_desc = NULL;
+#ifdef HAVE_LIBCRYPTO
+  if (ServerInfo.rsa_private_key != NULL)
+  {
+    RSA_free(ServerInfo.rsa_private_key);
+    ServerInfo.rsa_private_key = NULL;
+  }
+  if (ServerInfo.rsa_private_key_file != NULL)
+  {
+    MyFree(ServerInfo.rsa_private_key_file);
+    ServerInfo.rsa_private_key_file = NULL;
+  }
+#endif
+
+  /* clean out old resvs from the conf */
+  clear_conf_resv();
+
+  /* clean out AdminInfo */
+  MyFree(AdminInfo.name);
+  AdminInfo.name = NULL;
+  MyFree(AdminInfo.email);
+  AdminInfo.email = NULL;
+  MyFree(AdminInfo.description);
+  AdminInfo.description = NULL;
+
+  /* operator{} and class{} blocks are freed above */
+  /* clean out listeners */
+  close_listeners();
+
+  /* auth{}, quarantine{}, shared{}, connect{}, kill{}, deny{}, exempt{}
+   * and gecos{} blocks are freed above too
+   */
+
+  /* clean out general */
+  MyFree(ConfigFileEntry.servlink_path);
+  ConfigFileEntry.servlink_path = NULL;
+#ifdef HAVE_LIBCRYPTO
+  ConfigFileEntry.default_cipher_preference = NULL;
+#endif /* HAVE_LIBCRYPTO */
+
+  /* OK, that should be everything... */
+}
+
+/*
+ * flush_deleted_I_P
+ *
+ * inputs       - none
+ * output       - none
+ * side effects - This function removes I/P conf items
+ */
+
+static 
+void flush_deleted_I_P(void)
+{
+  struct ConfItem **tmp = &ConfigItemList;
+  struct ConfItem *tmp2;
+
+  /*
+   * flush out deleted I and P lines although still in use.
+   */
+  for (tmp = &ConfigItemList; (tmp2 = *tmp); )
+    {
+      if (!(tmp2->status & CONF_ILLEGAL))
+        tmp = &tmp2->next;
+      else
+        {
+          *tmp = tmp2->next;
+          tmp2->next = NULL;
+          if (!tmp2->clients)
+            free_conf(tmp2);
+        }
+    }
+}
+
+/*
+ * WriteKlineOrDline
+ *
+ * inputs       - kline or dline type flag
+ *              - client pointer to report to
+ *              - user name of target
+ *              - host name of target
+ *              - reason for target
+ *              - time_t cur_time
+ * output       - NONE
+ * side effects - This function takes care of
+ *                finding right kline or dline conf file, writing
+ *                the right lines to this file, 
+ *                notifying the oper that their kline/dline is in place
+ *                notifying the opers on the server about the k/d line
+ *                forwarding the kline onto the next U lined server
+ *                
+ */
+void 
+WriteKlineOrDline( KlineType type,
+		   struct Client *source_p,
+		   char *user,
+		   char *host,
+		   const char *reason,
+		   const char *oper_reason,
+		   const char *current_date,
+		   time_t cur_time)
+{
+  char buffer[1024];
+  FBFILE *out;
+  const char *filename;         /* filename to use for kline */
+
+  filename = get_conf_name(type);
+
+  if(type == DLINE_TYPE)
+    {
+      sendto_realops_flags(FLAGS_ALL, L_ALL,
+			   "%s added D-Line for [%s] [%s]",
+			   get_oper_name(source_p), host, reason);
+      sendto_one(source_p, ":%s NOTICE %s :Added D-Line [%s] to %s",
+		 me.name, source_p->name, host, filename);
+
+    }
+  else
+    {
+      sendto_realops_flags(FLAGS_ALL, L_ALL,
+			   "%s added K-Line for [%s@%s] [%s]",
+			   get_oper_name(source_p), user, host, reason);
+      sendto_one(source_p, ":%s NOTICE %s :Added K-Line [%s@%s]",
+		 me.name, source_p->name, user, host);
+    }
+
+  if ( (out = fbopen(filename, "a")) == NULL )
+    {
+      sendto_realops_flags(FLAGS_ALL, L_ALL,
+			   "*** Problem opening %s ", filename);
+      return;
+    }
+
+  if (oper_reason == NULL)
+    oper_reason = "";
+
+  if(type==KLINE_TYPE)
+    ircsprintf(buffer, "\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",%ld\n",
+               user,
+	       host,
+               reason,
+	       oper_reason,
+	       current_date,
+	       get_oper_name(source_p),
+               (long) cur_time);
+  else
+    ircsprintf(buffer, "\"%s\",\"%s\",\"%s\",\"%s\",\"%s\",%ld\n",
+               host,
+               reason,
+	       oper_reason,
+	       current_date,
+	       get_oper_name(source_p),
+               (long) cur_time);
+
+
+  if (fbputs(buffer,out) == -1)
+    {
+      sendto_realops_flags(FLAGS_ALL, L_ALL,
+			   "*** Problem writing to %s",filename);
+      fbclose(out);
+      return;
+    }
+      
+  fbclose(out);
+
+  if(type==KLINE_TYPE)
+    ilog(L_TRACE, "%s added K-Line for [%s@%s] [%s]",
+        source_p->name, user, host, reason);
+  else
+    ilog(L_TRACE, "%s added D-Line for [%s] [%s]",
+           get_oper_name(source_p), host, reason);
+}
+
+/* get_conf_name
+ *
+ * inputs       - type of conf file to return name of file for
+ * output       - pointer to filename for type of conf
+ * side effects - none
+ */
+const char *
+get_conf_name(KlineType type)
+{
+  if(type == CONF_TYPE)
+    {
+      return(ConfigFileEntry.configfile);
+    }
+  else if(type == KLINE_TYPE)
+    {
+      return(ConfigFileEntry.klinefile);
+    }
+
+  return(ConfigFileEntry.dlinefile);
+}
+
+/*
+ * conf_add_class_to_conf
+ * inputs       - pointer to config item
+ * output       - NONE
+ * side effects - Add a class pointer to a conf 
+ */
+
+void 
+conf_add_class_to_conf(struct ConfItem *aconf)
+{
+  if(aconf->className == NULL)
+    {
+      DupString(aconf->className,"default");
+      ClassPtr(aconf) = class0;
+      return;
+    }
+
+  ClassPtr(aconf) = find_class(aconf->className);
+
+  if(ClassPtr(aconf) == class0)
+    {
+      sendto_realops_flags(FLAGS_ALL, L_ALL,
+	   "Warning *** Defaulting to default class for missing class \"%s\"",
+			   aconf->className);
+      MyFree(aconf->className);
+      DupString(aconf->className,"default");
+      return;
+    }
+
+  if (ConfMaxLinks(aconf) < 0)
+    {
+      ClassPtr(aconf) = find_class(0);
+      MyFree(aconf->className);
+      DupString(aconf->className,"default");
+      return;
+    }
+}
+
+#define MAXCONFLINKS 150
+
+/*
+ * conf_add_server
+ *
+ * inputs       - pointer to config item
+ *		- pointer to link count already on this conf
+ * output       - NONE
+ * side effects - Add a connect block
+ */
+int 
+conf_add_server(struct ConfItem *aconf, int lcount)
+{
+  conf_add_class_to_conf(aconf);
+
+  if (lcount > MAXCONFLINKS || !aconf->host || !aconf->name)
+    {
+      sendto_realops_flags(FLAGS_ALL, L_ALL,"Bad connect block");
+      ilog(L_WARN, "Bad connect block");
+      return -1;
+    }
+
+  if (BadPtr(aconf->passwd) && !(aconf->flags & CONF_FLAGS_CRYPTLINK))
+    {
+      sendto_realops_flags(FLAGS_ALL, L_ALL,"Bad connect block, name %s",
+			   aconf->name);
+      ilog(L_WARN, "Bad connect block, host %s",aconf->name);
+      return -1;
+    }
+          
+  if( SplitUserHost(aconf) < 0 )
+    {
+      sendto_realops_flags(FLAGS_ALL, L_ALL,"Bad connect block, name %s",
+			   aconf->name);
+      ilog(L_WARN, "Bad connect block, name %s",aconf->name);
+      return -1;
+    }
+  lookup_confhost(aconf);
+  return 0;
+}
+
+/*
+ * conf_add_d_conf
+ * inputs       - pointer to config item
+ * output       - NONE
+ * side effects - Add a d/D line
+ */
+void
+conf_add_d_conf(struct ConfItem *aconf)
+{
+  if (aconf->host == NULL)
+    return;
+
+  aconf->user = NULL;
+
+  /* XXX - Should 'd' ever be in the old conf? For new conf we don't
+   *       need this anyway, so I will disable it for now... -A1kmm
+   */
+
+  if (parse_netmask(aconf->host, NULL, NULL) == HM_HOST)
+    {
+      ilog(L_WARN,"Invalid Dline %s ignored",aconf->host);
+      free_conf(aconf);
+    }
+  else
+    {
+      add_conf_by_address(aconf->host, CONF_DLINE, NULL, aconf);
+    }
+}
+
+/*
+ * conf_add_x_conf
+ * inputs       - pointer to config item
+ * output       - NONE
+ * side effects - Add a X line
+ */
+
+void 
+conf_add_x_conf(struct ConfItem *aconf)
+{
+  MyFree(aconf->user);
+  aconf->user = NULL;
+  aconf->name = aconf->host;
+  aconf->host = (char *)NULL;
+  aconf->next = x_conf;
+  x_conf = aconf;
+}
+
+/*
+ * conf_add_x_conf
+ * inputs       - pointer to config item
+ * output       - NONE
+ * side effects - Add an U line
+ */
+
+void 
+conf_add_u_conf(struct ConfItem *aconf)
+{
+  aconf->next = u_conf;
+  u_conf = aconf;
+}
+
+
+/*
+ * conf_add_fields
+ * inputs       - pointer to config item
+ *              - pointer to host_field
+ *		- pointer to pass_field
+ *              - pointer to user_field
+ *              - pointer to port_field
+ *		- pointer to class_field
+ * output       - NONE
+ * side effects - update host/pass/user/port fields of given aconf
+ */
+
+void 
+conf_add_fields(struct ConfItem *aconf,
+		char *host_field,
+		char *pass_field,
+		char *user_field,
+		char *port_field,
+		char *class_field)
+{
+  if(host_field)
+    DupString(aconf->host, host_field);
+  if(pass_field)
+    DupString(aconf->passwd, pass_field);
+  if(user_field)
+    DupString(aconf->user, user_field);
+  if(port_field)
+    aconf->port = atoi(port_field);
+  if(class_field)
+    DupString(aconf->className, class_field);
+}
+
+/*
+ * yyerror
+ *
+ * inputs	- message from parser
+ * output	- none
+ * side effects	- message to opers and log file entry is made
+ */
+void 
+yyerror(char *msg)
+{
+  char newlinebuf[BUFSIZE];
+
+  strip_tabs(newlinebuf, (const unsigned char *)linebuf, strlen(linebuf));
+
+  sendto_realops_flags(FLAGS_ALL, L_ALL,"%d: %s on line: %s",
+		       lineno + 1, msg, newlinebuf);
+
+  ilog(L_WARN, "%d: %s on line: %s",
+      lineno + 1, msg, newlinebuf);
+}
+
+int 
+conf_fbgets(char *lbuf,int max_size, FBFILE *fb)
+{
+  char* buff;
+
+  buff = fbgets(lbuf,max_size,fb);
+
+  if(!buff)
+    return 0;
+
+  return(strlen(lbuf));
+}
+
+int 
+conf_yy_fatal_error(char *msg)
+{
+  return 0;
+}
+
+#ifdef PACE_CONNECT
+
+/* void flush_expired_ips(void *unused)
+ *
+ * inputs	- none.
+ * output	- none.
+ * side effects	- Deletes all IP address entries which should have expired.
+ */
+void
+lmhush_expired_ips(void *unused)
+{
+  int i;
+  time_t expire_before = CurrentTime - ConfigFileEntry.throttle_time;
+  IP_ENTRY *ie, **iee;
+
+  for (i=0; i<IP_HASH_SIZE; i++)
+    {
+      for (iee=ip_hash_table+i, ie=*iee; ie; ie=*iee)
+	{
+	  if (ie->count == 0 && ie->last_attempt <= expire_before)
+	    {
+	      *iee=ie->next;
+	      ie->next = free_ip_entries;
+	      free_ip_entries = ie;
+	    }
+	  else
+	    iee = &ie->next;
+	}
+      *iee = NULL;
+    }
+}
+#endif
diff -urN ircd-hybrid-7/src/s_debug.c ircd-hybrid-7+lmh/src/s_debug.c
--- ircd-hybrid-7/src/s_debug.c	Sat May 25 00:34:51 2002
+++ ircd-hybrid-7+lmh/src/s_debug.c	Sat Jun 15 12:26:17 2002
@@ -44,7 +44,6 @@
 #include "linebuf.h"
 #include "memory.h"
 
-
 /*
  * Option string.  Must be before #ifdef DEBUGMODE.
  */
@@ -393,11 +392,20 @@
              number_servers_cached,
              (int)mem_servers_cached);
 
-  count_ip_hash(&number_ips_stored,&mem_ips_stored);
-  sendto_one(source_p, ":%s %d %s :iphash %u(%d)",
-             me.name, RPL_STATSDEBUG, source_p->name,
-             number_ips_stored,
-             (int)mem_ips_stored);
+  if(ConfigFileEntry.use_global_limits)
+  {
+    sendto_one(source_p, ":%s %d %s :hostname hash %d(%u)",
+	       me.name, RPL_STATSDEBUG, source_p->name,
+	       HOST_MAX, HOST_MAX * sizeof(struct HashEntry));
+  }
+  else
+  {
+    count_ip_hash(&number_ips_stored,&mem_ips_stored);
+    sendto_one(source_p, ":%s %d %s :iphash %u(%d)",
+               me.name, RPL_STATSDEBUG, source_p->name,
+               number_ips_stored,
+               (int)mem_ips_stored);
+  }
 
   total_memory = totww + total_channel_memory + conf_memory +
     class_count * sizeof(struct Class);
diff -urN ircd-hybrid-7/src/s_serv.c ircd-hybrid-7+lmh/src/s_serv.c
--- ircd-hybrid-7/src/s_serv.c	Tue Jun 11 02:02:30 2002
+++ ircd-hybrid-7+lmh/src/s_serv.c	Sat Jun 15 12:26:17 2002
@@ -104,6 +104,7 @@
   { "ZIP",   CAP_ZIP },
   { "TBURST", CAP_TBURST },
   { "PARA",  CAP_PARA },
+  { "UNKLN", CAP_UNKLN },
   { 0,           0 }
 };
 
@@ -549,7 +550,6 @@
   time_t             next = 0;
   struct Class*      cltmp;
   struct ConfItem*   con_conf = NULL;
-  int                con_class = 0;
 
   Debug((DEBUG_NOTICE,"Connection check at: %s", myctime(CurrentTime)));
 
@@ -586,10 +586,8 @@
        */
       client_p = find_server(aconf->name);
       
-      if (!client_p && (Links(cltmp) < MaxLinks(cltmp)) &&
-          (!connecting || (ClassType(cltmp) > con_class)))
+      if (!client_p && (CurrUsers(cltmp) < MaxUsers(cltmp)) && !connecting)
         {
-          con_class = ClassType(cltmp);
           con_conf = aconf;
           /* We connect only one at time... */
           connecting = TRUE;
diff -urN ircd-hybrid-7/src/s_user.c ircd-hybrid-7+lmh/src/s_user.c
--- ircd-hybrid-7/src/s_user.c	Wed Jun 12 02:40:21 2002
+++ ircd-hybrid-7+lmh/src/s_user.c	Sat Jun 15 12:26:17 2002
@@ -449,6 +449,9 @@
   if (IsDead(source_p))
     return CLIENT_EXITED;
   
+  if(ConfigFileEntry.use_global_limits)
+    add_to_hostname_hash_table(source_p->host, source_p);
+
   source_p->umodes |= FLAGS_INVISIBLE;
 
   Count.invisi++;
@@ -522,6 +525,9 @@
   /* Increment our total user count here */
   if (++Count.total > Count.max_tot)
     Count.max_tot = Count.total;
+
+  if(ConfigFileEntry.use_global_limits)
+    add_to_hostname_hash_table(source_p->host, source_p);
 
   source_p->servptr = find_server(user->server);
 
diff -urN ircd-hybrid-7/src/version.c.SH ircd-hybrid-7+lmh/src/version.c.SH
--- ircd-hybrid-7/src/version.c.SH	Tue Nov 13 08:59:01 2001
+++ ircd-hybrid-7+lmh/src/version.c.SH	Sat Jun 15 12:26:17 2002
@@ -51,11 +51,12 @@
 
 #include "patchlevel.h"
 #include "serno.h"
+#include "config.h"
 
 char *generation = "$generation";
 char *creation = "$creation";
 char *platform = "$uname";
-char *ircd_version = PATCHLEVEL;
+char *ircd_version = IRCDNAME;
 char *serno = SERIALNUM;
 
 char *infotext[] =
