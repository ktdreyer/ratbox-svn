temp-dline.diff

This patch adds support for temporary dlines to ircd-hybrid-7 and
aims to make both tdlines and tklines more efficient by grouping
them into four lists and checking their expiry as infrequently as
possible.

Normal dlines can still be placed as normal:
  /quote dline <nick|ip> :reason

However they can be made temporary by adding a time:
  /quote dline [duration] <nick|ip> :reason

The duration is in minutes, and the maximum length is 4 weeks.

This patch is used at your own risk and is not an official 
ircd-hybrid patch.

--
Lee H <lee@leeh.co.uk>


Index: include/s_conf.h
===================================================================
RCS file: /cvsroot/ircd-hybrid-7/include/s_conf.h,v
retrieving revision 7.180
diff -u -r7.180 s_conf.h
--- include/s_conf.h	24 May 2002 23:34:08 -0000	7.180
+++ include/s_conf.h	9 Jun 2002 11:48:33 -0000
@@ -317,8 +317,15 @@
 extern struct admin_info  AdminInfo;        /* defined in ircd.c */
 /* End GLOBAL section */
 
-dlink_list temporary_klines;
-dlink_list temporary_ip_klines;
+#define TEMP_MIN 	1
+#define TEMP_HOUR	2
+#define TEMP_DAY	3
+#define TEMP_WEEK	4
+
+dlink_list temporary_min;
+dlink_list temporary_hour;
+dlink_list temporary_day;
+dlink_list temporary_week;
 
 extern void clear_ip_hash_table(void);
 extern void iphash_stats(struct Client *,struct Client *,int,char **,FBFILE*);
@@ -378,9 +385,14 @@
 			       const char *oper_reason,
 			       const char *current_date, time_t cur_time );
 extern  void    add_temp_kline(struct ConfItem *);
+extern  void	add_temp_dline(struct ConfItem *);
 extern  void    report_temp_klines(struct Client *);
 extern  void    show_temp_klines(struct Client *, dlink_list *);
-extern  void    cleanup_tklines(void *notused);
+
+extern void cleanup_temps_min(void *);
+extern void cleanup_temps_hour(void *);
+extern void cleanup_temps_day(void *);
+extern void cleanup_temps_week(void *);
 
 extern  const   char *get_conf_name(KlineType);
 extern  int     rehash (int);
Index: modules/m_kline.c
===================================================================
RCS file: /cvsroot/ircd-hybrid-7/modules/m_kline.c,v
retrieving revision 1.102
diff -u -r1.102 m_kline.c
--- modules/m_kline.c	24 May 2002 23:34:20 -0000	1.102
+++ modules/m_kline.c	9 Jun 2002 11:48:34 -0000
@@ -90,12 +90,17 @@
 static int valid_user_host(struct Client *source_p, char *user, char *host);
 static int valid_wild_card(char *user, char *host);
 static int already_placed_kline(struct Client*, char*, char*);
+
 static void apply_kline(struct Client *source_p, struct ConfItem *aconf,
                         const char *reason, const char *oper_reason,
 			const char *current_date, time_t cur_time);
-
+static void apply_dline(struct Client *source_p, struct ConfItem *aconf,
+		        const char *reason, const char *oper_reason,
+			const char *current_date, time_t cur_time);
 static void apply_tkline(struct Client *source_p, struct ConfItem *aconf,
                          const char *current_date, int temporary_kline_time);
+static void apply_tdline(struct Client *source_p, struct ConfItem *aconf,
+		         const char *current_date, int temporary_kline_time);
 
 
 char buffer[IRCD_BUFSIZE];
@@ -397,6 +402,43 @@
  check_klines();
 }
 
+/* apply_dline
+ *
+ * input	- dline info
+ * output	- none
+ * side effects - dline is added to hashtable
+ */
+static void apply_dline(struct Client *source_p, struct ConfItem *aconf,
+		        const char *reason, const char *oper_reason,
+			const char *current_date, time_t cur_time)
+{
+  add_conf_by_address(aconf->host, CONF_DLINE, NULL, aconf);
+  WriteKlineOrDline(DLINE_TYPE, source_p, NULL, aconf->host, reason,
+		    oper_reason, current_date, cur_time);
+}
+
+/* apply_tdline
+ *
+ * input	- dline info
+ * output	- none
+ * side effects - tdline is added
+ */
+static void apply_tdline(struct Client *source_p, struct ConfItem *aconf,
+		         const char *current_date, int tdline_time)
+{
+  aconf->hold = CurrentTime + tdline_time;
+  add_temp_dline(aconf);
+  sendto_realops_flags(FLAGS_ALL, L_ALL,
+		       "%s added temporary %d min. D-Line for [%s] [%s]",
+		       source_p->name, tdline_time/60, 
+		       aconf->host, aconf->passwd);
+
+  sendto_one(source_p, ":%s NOTICE %s :Added temporary %d min. D-Line for [%s]",
+             me.name, source_p->name, tdline_time/60, aconf->host);
+  ilog(L_TRACE, "%s added temporary %d min. D-Line for [%s] [%s]",
+       source_p->name, tdline_time/60, aconf->host, aconf->passwd);
+}
+
 /*
  * valid_tkline()
  * 
@@ -430,8 +472,8 @@
   if(result == 0)
     result = 1;
 
-  if(result > (24*60))
-    result = (24*60); /* Max it at 24 hours */
+  if(result > (24*60*7*4))
+    result = (24*60*7*4); /* Max it at 4 weeks */
 
   result = (time_t)result * (time_t)60;  /* turn it into seconds */
 
@@ -574,6 +616,8 @@
   char dlbuffer[1024];
   const char* current_date;
   time_t cur_time;
+  time_t tdline_time = 0;
+  int loc = 0;
 
   if(!IsOperK(source_p))
     {
@@ -581,7 +625,23 @@
       return;
     }
 
-  dlhost = parv[1];
+  loc++;
+
+  tdline_time = valid_tkline(source_p, parv[loc]);
+
+  if(tdline_time == -1)
+    return;
+  else if(tdline_time) 
+    loc++;
+
+  if(parc < loc+1)
+  {
+    sendto_one(source_p, form_str(ERR_NEEDMOREPARAMS),
+	       me.name, source_p->name, "DLINE");
+    return;
+  }
+  
+  dlhost = parv[loc];
   strlcpy(cidr_form_host, dlhost, HOSTLEN);
   cidr_form_host[HOSTLEN] = '\0';
 
@@ -592,7 +652,7 @@
               me.name, parv[0]);
    return;
 #else
-      if (!(target_p = find_chasing(source_p, parv[1], NULL)))
+      if (!(target_p = find_chasing(source_p, parv[loc], NULL)))
         return;
 
       if(!target_p->user)
@@ -658,14 +718,15 @@
 #endif
     }
 
+  loc++;
 
-  if (parc > 2) /* host :reason */
+  if (parc >= loc+1) /* host :reason */
     {
-      if ( valid_comment(source_p,parv[2]) == 0 )
+      if ( valid_comment(source_p, parv[loc]) == 0 )
 	return;
 
-      if(*parv[2])
-        reason = parv[2];
+      if(*parv[loc])
+        reason = parv[loc];
       else
         reason = "No reason";
     }
@@ -726,18 +787,23 @@
       oper_reason++;
     }
 
-  ircsprintf(dlbuffer, "%s (%s)",reason, current_date);
-
   aconf->status = CONF_DLINE;
   DupString(aconf->host, dlhost);
-  DupString(aconf->passwd, dlbuffer);
+  
+  if(tdline_time)
+  {
+    ircsprintf(dlbuffer, "Temporary D-line %d min. - %s (%s)",
+	       (int)(tdline_time/60), reason, current_date);
+    DupString(aconf->passwd, dlbuffer);
+    apply_tdline(source_p, aconf, current_date, tdline_time);
+  }
+  else
+  {
+    ircsprintf(dlbuffer, "%s (%s)",reason, current_date);
+    DupString(aconf->passwd, dlbuffer);
+    apply_dline(source_p, aconf, reason, oper_reason, current_date, cur_time);
+  }
 
-  add_conf_by_address(aconf->host, CONF_DLINE, NULL, aconf);
-  /*
-   * Write dline to configuration file
-   */
-  WriteKlineOrDline(DLINE_TYPE, source_p, NULL, dlhost, reason,
-		    oper_reason, current_date, cur_time);
   check_klines();
 } /* m_dline() */
 
Index: modules/m_unkline.c
===================================================================
RCS file: /cvsroot/ircd-hybrid-7/modules/m_unkline.c,v
retrieving revision 1.45
diff -u -r1.45 m_unkline.c
--- modules/m_unkline.c	24 May 2002 23:34:23 -0000	1.45
+++ modules/m_unkline.c	9 Jun 2002 11:48:35 -0000
@@ -77,7 +77,8 @@
 #endif
 
 static int flush_write(struct Client *, FBFILE* , char *, char *);
-static int remove_tkline_match(char *,char *);
+static int remove_temp_match(char *,char *);
+static int remove_temp_match_list(char *, char *, dlink_list *);
 
 
 /*
@@ -135,7 +136,7 @@
       return;
     }
 
-  if (remove_tkline_match(host, user))
+  if (remove_temp_match(host, user))
     {
       sendto_one(source_p,
 		 ":%s NOTICE %s :Un-klined [%s@%s] from temporary k-lines",
@@ -287,30 +288,45 @@
  * Side effects: Any matching tklines are removed.
  */
 static int
-remove_tkline_match(char *host, char *user)
+remove_temp_match(char *host, char *user)
 {
-  struct ConfItem *tk_c;
-  dlink_node *tk_n;
+  if(remove_temp_match_list(host, user, &temporary_hour) ||
+     remove_temp_match_list(host, user, &temporary_day) ||
+     remove_temp_match_list(host, user, &temporary_min) ||
+     remove_temp_match_list(host, user, &temporary_week))
+    return YES;
+
+  return NO;
+}
+
+static int
+remove_temp_match_list(char *host, char *user, dlink_list *temp_list)
+{
+  struct ConfItem *aconf;
+  dlink_node *ptr;
   struct irc_inaddr addr, caddr;
   int nm_t, cnm_t, bits, cbits;
   nm_t = parse_netmask(host, &addr, &bits);
 
-  for (tk_n=temporary_klines.head; tk_n; tk_n=tk_n->next)
+  for(ptr = temp_list->head; ptr; ptr = ptr->next)
     {
-      tk_c = (struct ConfItem*)tk_n->data;
-      cnm_t = parse_netmask(tk_c->host, &caddr, &cbits);
-      if (cnm_t != nm_t || irccmp(user, tk_c->user))
+      aconf = (struct ConfItem*)ptr->data;
+
+      cnm_t = parse_netmask(aconf->host, &caddr, &cbits);
+
+      if (cnm_t != nm_t || (user && irccmp(user, aconf->user)))
 	continue;
-      if ((nm_t==HM_HOST && !irccmp(tk_c->host, host)) ||
+
+      if ((nm_t==HM_HOST && !irccmp(aconf->host, host)) ||
 	  (nm_t==HM_IPV4 && bits==cbits && match_ipv4(&addr, &caddr, bits))
 #ifdef IPV6
 	  || (nm_t==HM_IPV6 && bits==cbits && match_ipv6(&addr, &caddr, bits))
 #endif
 	  )
 	{
-	  dlinkDelete(tk_n, &temporary_klines);
-	  free_dlink_node(tk_n);
-	  delete_one_address_conf(tk_c->host, tk_c);
+	  dlinkDelete(ptr, temp_list);
+	  free_dlink_node(ptr);
+	  delete_one_address_conf(aconf->host, aconf);
 	  return YES;
 	}
     }
@@ -333,7 +349,8 @@
   FBFILE* in;
   FBFILE* out;
   char  buf[BUFSIZE], buff[BUFSIZE], temppath[BUFSIZE], *p;
-  const char  *filename,*cidr, *found_cidr;
+  const char  *filename, *found_cidr;
+  char *cidr;
   int pairme = NO, error_on_write = NO;
   mode_t oldumask;
 
@@ -356,6 +373,18 @@
       return;
     }
 #endif
+
+  if(remove_temp_match(cidr, NULL))
+  {
+    sendto_one(source_p,
+	       ":%s NOTICE %s :Un-dlined [%s] from temporary D-lines",
+	       me.name, parv[0], cidr);
+    sendto_realops_flags(FLAGS_ALL, L_ALL,
+                         "%s has removed the temporary D-Line for: [%s]",
+			 get_oper_name(source_p), cidr);
+    ilog(L_NOTICE, "%s removed temporary D-Line for [%s]", parv[0], cidr);
+    return;
+  }
 
   filename = get_conf_name(DLINE_TYPE);
 
Index: src/ircd.c
===================================================================
RCS file: /cvsroot/ircd-hybrid-7/src/ircd.c,v
retrieving revision 7.236
diff -u -r7.236 ircd.c
--- src/ircd.c	4 Jun 2002 05:30:16 -0000	7.236
+++ src/ircd.c	9 Jun 2002 11:48:36 -0000
@@ -740,7 +740,10 @@
 
   eventAddIsh("cleanup_glines", cleanup_glines, NULL, CLEANUP_GLINES_TIME);
 
-  eventAddIsh("cleanup_tklines", cleanup_tklines, NULL, CLEANUP_TKLINES_TIME);
+  eventAddIsh("cleanup_temps_min", cleanup_temps_min, NULL, 60);
+  eventAddIsh("cleanup_temps_hour", cleanup_temps_hour, NULL, 3600);
+  eventAddIsh("cleanup_temps_day", cleanup_temps_day, NULL, 86400);
+  eventAddIsh("cleanup_temps_week", cleanup_temps_week, NULL, 604800);
 
   /* We want try_connections to be called as soon as possible now! -- adrian */
   /* No, 'cause after a restart it would cause all sorts of nick collides */
Index: src/s_conf.c
===================================================================
RCS file: /cvsroot/ircd-hybrid-7/src/s_conf.c,v
retrieving revision 7.304
diff -u -r7.304 s_conf.c
--- src/s_conf.c	31 May 2002 02:21:05 -0000	7.304
+++ src/s_conf.c	9 Jun 2002 11:48:39 -0000
@@ -73,7 +73,8 @@
 static void     read_conf(FBFILE*);
 static void     clear_out_old_conf(void);
 static void     flush_deleted_I_P(void);
-static void     expire_tklines(dlink_list *);
+static void	add_temp_line(struct ConfItem *);
+static void     expire_temps(dlink_list *, int);
 static int 	is_attached(struct Client *client_p, struct ConfItem *aconf);
 
 FBFILE* conf_fbfile_in;
@@ -1655,40 +1656,80 @@
 void
 add_temp_kline(struct ConfItem *aconf)
 {
-  dlink_node *kill_node;
-  kill_node = make_dlink_node();
-  dlinkAdd(aconf, kill_node, &temporary_klines);
+  add_temp_line(aconf);
   aconf->flags |= CONF_FLAGS_TEMPORARY;
   add_conf_by_address(aconf->host, CONF_KILL, aconf->user, aconf);
 }
 
-/*
- * cleanup_tklines
+/* add_temp_dline
  *
- * inputs       - NONE
- * output       - NONE
- * side effects - call function to expire tklines
- *                This is an event started off in ircd.c
+ * input	- pointer to struct ConfItem
+ * output	- none
+ * side effects - added to tkline link list and address hash
  */
+void add_temp_dline(struct ConfItem *aconf)
+{
+  add_temp_line(aconf);
+  aconf->flags |= CONF_FLAGS_TEMPORARY;
+  add_conf_by_address(aconf->host, CONF_DLINE, aconf->user, aconf);
+}
+
+void
+cleanup_temps_min(void *notused)
+{
+  expire_temps(&temporary_min, TEMP_MIN);
+}
+
+void
+cleanup_temps_hour(void *notused)
+{
+  expire_temps(&temporary_hour, TEMP_HOUR);
+}
+
+void
+cleanup_temps_day(void *notused)
+{
+  expire_temps(&temporary_day, TEMP_DAY);
+}
+
 void
-cleanup_tklines(void *notused)
+cleanup_temps_week(void *notused)
 {
-  expire_tklines(&temporary_klines);
+  expire_temps(&temporary_week, TEMP_WEEK);
+}
+
+static void
+add_temp_line(struct ConfItem *aconf)
+{
+  dlink_node *m;
+
+  m = make_dlink_node();
+  
+  if(aconf->hold > CurrentTime + (10080*60))
+    dlinkAdd(aconf, m, &temporary_week);
+  else if(aconf->hold > CurrentTime + (1440*60))
+    dlinkAdd(aconf, m, &temporary_day);
+  else if(aconf->hold > CurrentTime + (60*60))
+    dlinkAdd(aconf, m, &temporary_hour);
+  else
+    dlinkAdd(aconf, m, &temporary_min);
 }
 
 /*
- * expire_tklines
+ * expire_temps
  *
- * inputs       - tkline list pointer
+ * inputs       - list pointer
+ * 		- type
  * output       - NONE
  * side effects - expire tklines
  */
 static void
-expire_tklines(dlink_list *tklist)
+expire_temps(dlink_list *tklist, int type)
 {
   dlink_node *kill_node;
   dlink_node *next_node;
   struct ConfItem *kill_ptr;
+
   for (kill_node = tklist->head; kill_node; kill_node = next_node)
     {
       kill_ptr = kill_node->data;
@@ -1697,15 +1738,48 @@
       if (kill_ptr->hold <= CurrentTime)
 	{
           /* Alert opers that a TKline expired - Hwy */
-          sendto_realops_flags(FLAGS_ALL, L_ALL,
+          if(kill_ptr->status & CONF_KILL)
+            sendto_realops_flags(FLAGS_ALL, L_ALL,
 			       "Temporary K-line for [%s@%s] expired",
 			       (kill_ptr->user) ? kill_ptr->user : "*",
 			       (kill_ptr->host) ? kill_ptr->host : "*");
 
+	  /* temp dline */
+	  else
+            sendto_realops_flags(FLAGS_ALL, L_ALL,
+			       "Temporary D-line for [%s] expired",
+			       kill_ptr->host);
+
 	  delete_one_address_conf(kill_ptr->host, kill_ptr);
 	  dlinkDelete(kill_node, tklist);
 	  free_dlink_node(kill_node);
 	}
+      
+      else if((type == TEMP_WEEK && kill_ptr->hold < CurrentTime + 10080) ||
+              (type == TEMP_DAY && kill_ptr->hold < CurrentTime + 1440) ||
+	      (type == TEMP_HOUR && kill_ptr->hold < CurrentTime + 60))
+      {
+        /* expires within the hour.. */
+        if(kill_ptr->hold < CurrentTime + (60*60))
+	{
+          dlinkDelete(kill_node, tklist);
+	  dlinkAdd(kill_ptr, kill_node, &temporary_min);
+	}
+
+	/* expires within the day */
+	else if(kill_ptr->hold < CurrentTime + (1440*60))
+	{
+          dlinkDelete(kill_node, tklist);
+	  dlinkAdd(kill_ptr, kill_node, &temporary_hour);
+	}
+
+	/* expires within the week */
+	else if(kill_ptr->hold < CurrentTime + (10080*60))
+	{
+          dlinkDelete(kill_node, tklist);
+	  dlinkAdd(kill_ptr, kill_node, &temporary_day);
+	}
+      }
     }
 }
 
