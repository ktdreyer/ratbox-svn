                                    KSERVER Challenge/Anti-hijack protocol
                                    ======================================
   (Based on draft by A1kmm)
   (Rewritten by David-T)

1.0: Goal of this protocol:
     ---------------------

	To reduce the risk of attacks relating to password sniffing or
	replay attacks allowing unauthorised connections to gain server
	priviledges.

1.1: Conventions of this document:
     ----------------------------

	* MUST means that a server is not "compliant" unless it does this.
	* MUST NOT means that a server is not "compliant" if it does this.
	* SHOULD means that a server is at most "conditionally compliant"
	  if it does not do this.
	* SHOULD NOT means that a server is at most "conditionally compliant"
	  if it does this.
	* MAY means that a server may choose whether or not to do this.

1.2: Conventions of this protocol:
     ----------------------------

	This protocol is based on the IRC protocol as described in RFC1459,
	and extensions implemented on Efnet as described in other documents
	in this directory.

	Any encrypted strings which are transmitted across the network in
	accordance with this document shall be BASE64 encoded, with the
	most significant bits of the most significant byte transmitted
	first, followed by bits/bytes of decreasing significance.
  
2.0: Configuration of KSERVER links:
     ------------------------------

	Every server which supports KSERVER links has an RSA private key
	stored in a configuration file.  Care must be taken to ensure this
	file is accessible only to the ircd user.  For every link to another
 	server with KSERVER support, the public component of that server's
	RSA key is stored instead of the traditional password or
	password hash.

	A server which is configured to make a KSERVER link to another
	server MUST NOT fall back on to any other server authentification
	scheme regardless of what the remote server sends.

2.1: Connection authentication:
     -------------------------

	When a server (A) wants to initiate a KSERVER link with another
	server (B), it generates a 64 byte string (M) of random data using a
	SRNG, and encrypts it to B's public key.

        Let M1 denote the first 32 bytes of M.
        Let M2 denote the remaining 32 bytes.

	It SHOULD then send the CAPAB command with its capabilities,
	including the 'KSERVER' capability, and MUST then send a KSERVER
	command.  It MUST store M1.  M2 MUST be stored if the link is to
	support the 'MSGHASH' capability, (see msghash.txt) otherwise,
	it MAY be discarded.

	Any server that sends the KSERVER command SHOULD NOT
	send a PASS command across KSERVER links and MUST support the TS
	protocol.  Any PASS command received from a KSERVER link MUST
	be ingored.  A server MUST NOT send an initial SERVER command
	over a KSERVER link, although SERVER commands are still used to
	introduce remote servers.

	Let E denote the base64 encoded encrypted version of M.
	The format of the KSERVER command is:

		KSERVER <irc.server-a.com> <E> :<Server Description>

	No hopcount is necessary, as it will always be 0 for the KSERVER
	command.

	The server SHOULD NOT send a SVINFO command yet, and MUST NOT send
	a connect burst, nor accept commands which are restricted to server
	links from the remote server at this point.  On receipt, B SHOULD
	check that the user@host for the remote server matches the configured
	value, and SHOULD drop the link if it does not. B MUST then use its
	private key to decrypt the 64 byte string.

	B will also generate another 64 byte string of random data from a
	SRNG, denoted by N.

	Let N1 denote the first 32 bytes of N.
	Let N2 denote the remaining 32 bytes.

	B will then encrypt the entire random string, N, to A's public key,
	the base64 encoding of this encrypted string is denoted <F>.

	B MUST then send a KSERVER command as above, followed by a KAUTH
	command:

		KSERVER <irc.server-b.com> <F> :Server description
		KAUTH <M1>

	B SHOULD NOT send the SVINFO command yet.  It MUST NOT send a connect
	burst nor accept commands which are restricted to server
	links from the remote server at this point.

	Following sending this, B MAY discard M1. It MUST save N1 at this
	point. M2 and N2 MUST be stored if the link supports the 'MSGHASH'
	capability, (see msghash.txt) otherwise, it MAY be discarded.

	Servers MUST NOT send M2 or N2 across the network in plain text.

	Following the receipt of this message A MUST compare M1 with
	its locally stored copy. It MUST drop the link to B if they do not
	match, otherwise it SHOULD consider B authenticated and send the
	SVINFO command, followed by the normal connect burst.  It SHOULD
	also accept privileged server commands from B.
	It MAY then discard the value of M1, but MUST store the value of
	M2, if the link is to support the 'MSGHASH' capability see
	msghash.txt), otherwise M2 may be discared.  It MUST then use its
	private key to decrypt N1 and N2 from F.  A MUST then send the
	following response:

		KAUTH <N1>

        Following the receipt of this message B MUST compare N1 with
        its locally stored copy. It MUST drop the link to A if they do not
        match, otherwise it SHOULD consider A authenticated and accept
        server commands from it. It MAY then discard the value of N1,
        but MUST store the value of N2, if the link is to support the
        'MSGHASH' capability (see msghash.txt).

	B SHOULD then send the SVINFO command, followed by a normal connect
	burst.

	The connection then continues as normal.

Last modified:	2001-04-08
